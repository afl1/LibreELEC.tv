From 251b729f546a6f1804bb1f4a5e06fc8d646058df Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 00:27:49 +0000
Subject: [PATCH 01/16] Manually apply Connor's changes to include/panfrost_job

---
 .../drivers/panfrost/include/panfrost-job.h   | 428 ++++++++++++++----
 1 file changed, 346 insertions(+), 82 deletions(-)

diff --git a/src/gallium/drivers/panfrost/include/panfrost-job.h b/src/gallium/drivers/panfrost/include/panfrost-job.h
index e174c9239e..ad86cf01cd 100644
--- a/src/gallium/drivers/panfrost/include/panfrost-job.h
+++ b/src/gallium/drivers/panfrost/include/panfrost-job.h
@@ -236,6 +236,158 @@ struct mali_blend_equation {
 #endif
 } __attribute__((packed));
 
+/* Used with channel swizzling */
+enum mali_channel {
+	MALI_CHANNEL_RED = 0,
+	MALI_CHANNEL_GREEN = 1,
+	MALI_CHANNEL_BLUE = 2,
+	MALI_CHANNEL_ALPHA = 3,
+	MALI_CHANNEL_ZERO = 4,
+	MALI_CHANNEL_ONE = 5,
+	MALI_CHANNEL_RESERVED_0 = 6,
+	MALI_CHANNEL_RESERVED_1 = 7,
+};
+
+struct mali_channel_swizzle {
+	enum mali_channel r : 3;
+	enum mali_channel g : 3;
+	enum mali_channel b : 3;
+	enum mali_channel a : 3;
+} __attribute__((packed));
+
+/* Compressed per-pixel formats. Each of these formats expands to one to four
+ * floating-point or integer numbers, as defined by the OpenGL specification.
+ * There are various places in OpenGL where the user can specify a compressed
+ * format in memory, which all use the same 8-bit enum in the various
+ * descriptors, although different hardware units support different formats.
+ */
+
+/* The top 3 bits specify how the bits of each component are interpreted. */
+
+/* e.g. R11F_G11F_B10F */
+#define MALI_FORMAT_SPECIAL (2 << 5)
+
+/* signed normalized, e.g. RGBA8_SNORM */
+#define MALI_FORMAT_SNORM (3 << 5)
+
+/* e.g. RGBA8UI */
+#define MALI_FORMAT_UINT (4 << 5)
+
+/* e.g. RGBA8 and RGBA32F */
+#define MALI_FORMAT_UNORM (5 << 5)
+
+/* e.g. RGBA8I and RGBA16F */
+#define MALI_FORMAT_SINT (6 << 5)
+
+/* These formats seem to largely duplicate the others. They're used at least
+ * for Bifrost framebuffer output.
+ */
+#define MALI_FORMAT_SPECIAL2 (7 << 5)
+
+/* If the high 3 bits are 3 to 6 these two bits say how many components
+ * there are.
+ */
+#define MALI_NR_CHANNELS(n) ((n - 1) << 3)
+
+/* If the high 3 bits are 3 to 6, then the low 3 bits say how big each
+ * component is, except the special MALI_CHANNEL_FLOAT which overrides what the
+ * bits mean.
+ */
+
+#define MALI_CHANNEL_8 3
+
+#define MALI_CHANNEL_16 4
+
+#define MALI_CHANNEL_32 5
+
+/* For MALI_FORMAT_SINT it means a half-float (e.g. RG16F). For
+ * MALI_FORMAT_UNORM, it means a 32-bit float.
+ */
+#define MALI_CHANNEL_FLOAT 7
+
+enum mali_format {
+	MALI_RGB10_A2_UNORM = MALI_FORMAT_SPECIAL | 0x3,
+	MALI_RGB10_A2_SNORM = MALI_FORMAT_SPECIAL | 0x5,
+	MALI_RGB10_A2UI     = MALI_FORMAT_SPECIAL | 0x7,
+	MALI_RGB10_A2I      = MALI_FORMAT_SPECIAL | 0x9,
+	MALI_R32_FIXED      = MALI_FORMAT_SPECIAL | 0x11,
+	MALI_RG32_FIXED     = MALI_FORMAT_SPECIAL | 0x12,
+	MALI_RGB32_FIXED    = MALI_FORMAT_SPECIAL | 0x13,
+	MALI_RGBA32_FIXED   = MALI_FORMAT_SPECIAL | 0x14,
+	MALI_R11F_G11F_B10F = MALI_FORMAT_SPECIAL | 0x19,
+	/* Only used for varyings, to indicate the transformed gl_Position */
+	MALI_VARYING_POS    = MALI_FORMAT_SPECIAL | 0x1e,
+	/* Only used for varyings, to indicate that the write should be
+	 * discarded.
+	 */
+	MALI_VARYING_DISCARD = MALI_FORMAT_SPECIAL | 0x1f,
+
+	MALI_R8_SNORM     = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_8,
+	MALI_R16_SNORM    = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_16,
+	MALI_R32_SNORM    = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_32,
+	MALI_RG8_SNORM    = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_8,
+	MALI_RG16_SNORM   = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_16,
+	MALI_RG32_SNORM   = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_32,
+	MALI_RGB8_SNORM   = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_8,
+	MALI_RGB16_SNORM  = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_16,
+	MALI_RGB32_SNORM  = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_32,
+	MALI_RGBA8_SNORM  = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_8,
+	MALI_RGBA16_SNORM = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_16,
+	MALI_RGBA32_SNORM = MALI_FORMAT_SNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_32,
+
+	MALI_R8UI     = MALI_FORMAT_UINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_8,
+	MALI_R16UI    = MALI_FORMAT_UINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_16,
+	MALI_R32UI    = MALI_FORMAT_UINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_32,
+	MALI_RG8UI    = MALI_FORMAT_UINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_8,
+	MALI_RG16UI   = MALI_FORMAT_UINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_16,
+	MALI_RG32UI   = MALI_FORMAT_UINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_32,
+	MALI_RGB8UI   = MALI_FORMAT_UINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_8,
+	MALI_RGB16UI  = MALI_FORMAT_UINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_16,
+	MALI_RGB32UI  = MALI_FORMAT_UINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_32,
+	MALI_RGBA8UI  = MALI_FORMAT_UINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_8,
+	MALI_RGBA16UI = MALI_FORMAT_UINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_16,
+	MALI_RGBA32UI = MALI_FORMAT_UINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_32,
+
+	MALI_R8_UNORM = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_8,
+	MALI_R16_UNORM = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_16,
+	MALI_R32_UNORM = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_32,
+	MALI_R32F = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(1) | MALI_CHANNEL_FLOAT,
+	MALI_RG8_UNORM    = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_8,
+	MALI_RG16_UNORM   = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_16,
+	MALI_RG32_UNORM   = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_32,
+	MALI_RG32F = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(2) | MALI_CHANNEL_FLOAT,
+	MALI_RGB8_UNORM   = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_8,
+	MALI_RGB16_UNORM  = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_16,
+	MALI_RGB32_UNORM  = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_32,
+	MALI_RGB32F = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(3) | MALI_CHANNEL_FLOAT,
+	MALI_RGBA8_UNORM  = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_8,
+	MALI_RGBA16_UNORM = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_16,
+	MALI_RGBA32_UNORM = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_32,
+	MALI_RGBA32F = MALI_FORMAT_UNORM | MALI_NR_CHANNELS(4) | MALI_CHANNEL_FLOAT,
+
+	MALI_R8I     = MALI_FORMAT_SINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_8,
+	MALI_R16I    = MALI_FORMAT_SINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_16,
+	MALI_R32I    = MALI_FORMAT_SINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_32,
+	MALI_R16F    = MALI_FORMAT_SINT | MALI_NR_CHANNELS(1) | MALI_CHANNEL_FLOAT,
+	MALI_RG8I    = MALI_FORMAT_SINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_8,
+	MALI_RG16I   = MALI_FORMAT_SINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_16,
+	MALI_RG32I   = MALI_FORMAT_SINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_32,
+	MALI_RG16F   = MALI_FORMAT_SINT | MALI_NR_CHANNELS(2) | MALI_CHANNEL_FLOAT,
+	MALI_RGB8I   = MALI_FORMAT_SINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_8,
+	MALI_RGB16I  = MALI_FORMAT_SINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_16,
+	MALI_RGB32I  = MALI_FORMAT_SINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_32,
+	MALI_RGB16F  = MALI_FORMAT_SINT | MALI_NR_CHANNELS(3) | MALI_CHANNEL_FLOAT,
+	MALI_RGBA8I  = MALI_FORMAT_SINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_8,
+	MALI_RGBA16I = MALI_FORMAT_SINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_16,
+	MALI_RGBA32I = MALI_FORMAT_SINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_32,
+	MALI_RGBA16F = MALI_FORMAT_SINT | MALI_NR_CHANNELS(4) | MALI_CHANNEL_FLOAT,
+
+	MALI_RGBA4      = MALI_FORMAT_SPECIAL2 | 0x8,
+	MALI_RGBA8_2    = MALI_FORMAT_SPECIAL2 | 0xd,
+	MALI_RGB10_A2_2 = MALI_FORMAT_SPECIAL2 | 0xe,
+};
+
+
 /* Alpha coverage is encoded as 4-bits (from a clampf), with inversion
  * literally performing a bitwise invert. This function produces slightly wrong
  * results and I'm not sure why; some rounding issue I suppose... */
@@ -267,11 +419,49 @@ struct mali_blend_meta {
          * - 0x19 normally
          * - 0x3 when this slot is unused (everything else is 0 except the index)
          * - 0x11 when this is the fourth slot (and it's used)
++	 * - 0 when there is a blend shader
          */
         u16 unk2;
         /* increments from 0 to 3 */
         u16 index;
-        u32 unk3; // = 0x10ed688
+
+	union {
+		struct {
+			/* So far, I've only seen:
+			 * - R001 for 1-component formats
+			 * - RG01 for 2-component formats
+			 * - RGB1 for 3-component formats
+			 * - RGBA for 4-component formats
+			 */
+			u32 swizzle : 12;
+			enum mali_format format : 8;
+
+			/* Type of the shader output variable. Note, this can
+			 * be different from the format.
+			 *
+			 * 0: f16 (mediump float)
+			 * 1: f32 (highp float)
+			 * 2: i32 (highp int)
+			 * 3: u32 (highp uint)
+			 * 4: i16 (mediump int)
+			 * 5: u16 (mediump uint)
+			 */
+			u32 shader_type : 3;
+			u32 zero : 9;
+		};
+
+		/* Only the low 32 bits of the blend shader are stored, the
+		 * high 32 bits are implicitly the same as the original shader.
+		 * According to the kernel driver, the program counter for
+		 * shaders is actually only 24 bits, so shaders cannot cross
+		 * the 2^24-byte boundary, and neither can the blend shader.
+		 * The blob handles this by allocating a 2^24 byte pool for
+		 * shaders, and making sure that any blend shaders are stored
+		 * in the same pool as the original shader. The kernel will
+		 * make sure this allocation is aligned to 2^24 bytes.
+		 */
+		u32 blend_shader;
+	};
 #endif
 } __attribute__((packed));
 
@@ -423,55 +613,166 @@ struct mali_payload_set_value {
 #define MALI_VERTEX_ID   (MALI_SPECIAL_ATTRIBUTE_BASE + 0)
 #define MALI_INSTANCE_ID (MALI_SPECIAL_ATTRIBUTE_BASE + 1)
 
-struct mali_attr {
-        mali_ptr elements;
-        u32 stride;
-        u32 size;
-} __attribute__((packed));
+/*
+ * Mali Attributes
+ *
+ * This structure lets the attribute unit compute the address of an attribute
+ * given the vertex and instance ID. Unfortunately, the way this works is
+ * rather complicated when instancing is enabled.
+ *
+ * To explain this, first we need to explain how compute and vertex threads are
+ * dispatched. This is a guess (although a pretty firm guess!) since the
+ * details are mostly hidden from the driver, except for attribute instancing.
+ * When a quad is dispatched, it receives a single, linear index. However, we
+ * need to translate that index into a (vertex id, instance id) pair, or a
+ * (local id x, local id y, local id z) triple for compute shaders (although
+ * vertex shaders and vertex shaders are handled almost identically).
+ * Focusing on vertex shaders, one option would be to do:
+ *
+ * vertex_id = linear_id % num_vertices
+ * instance_id = linear_id / num_vertices
+ *
+ * but this involves a costly division and modulus by an arbitrary number.
+ * Instead, we could pad num_vertices. We dispatch padded_num_vertices *
+ * num_instances threads instead of num_vertices * num_instances, which results
+ * in some "extra" threads with vertex_id >= num_vertices, which we have to
+ * discard.  The more we pad num_vertices, the more "wasted" threads we
+ * dispatch, but the division is potentially easier.
+ *
+ * One straightforward choice is to pad num_vertices to the next power of two,
+ * which means that the division and modulus are just simple bit shifts and
+ * masking. But the actual algorithm is a bit more complicated. The thread
+ * dispatcher has special support for dividing by 3, 5, 7, and 9, in addition
+ * to dividing by a power of two. This is possibly using the technique
+ * described in patent US20170010862A1. As a result, padded_num_vertices can be
+ * 1, 3, 5, 7, or 9 times a power of two. This results in less wasted threads,
+ * since we need less padding.
+ *
+ * padded_num_vertices is picked by the hardware. The driver just specifies the
+ * actual number of vertices. At least for Mali G71, the first few cases are
+ * given by:
+ *
+ * num_vertices	| padded_num_vertices
+ * 3		| 4
+ * 4-7		| 8
+ * 8-11		| 12 (3 * 4)
+ * 12-15	| 16
+ * 16-19	| 20 (5 * 4)
+ *
+ * Note that padded_num_vertices is a multiple of four (presumably because
+ * threads are dispatched in groups of 4). Also, padded_num_vertices is always
+ * at least one more than num_vertices, which seems like a quirk of the
+ * hardware. For larger num_vertices, the hardware uses the following
+ * algorithm: using the binary representation of num_vertices, we look at the
+ * most significant set bit as well as the following 3 bits. Let n be the
+ * number of bits after those 4 bits. Then we set padded_num_vertices according
+ * to the following table:
+ *
+ * high bits	| padded_num_vertices
+ * 1000		| 9 * 2^n
+ * 1001		| 5 * 2^(n+1)
+ * 101x		| 3 * 2^(n+2)
+ * 110x		| 7 * 2^(n+1)
+ * 111x		| 2^(n+4)
+ *
+ * For example, if num_vertices = 70 is passed to glDraw(), its binary
+ * representation is 1000110, so n = 3 and the high bits are 1000, and
+ * therefore padded_num_vertices = 9 * 2^3 = 72.
+ *
+ * The attribute unit works in terms of the original linear_id. if
+ * num_instances = 1, then they are the same, and everything is simple.
+ * However, with instancing things get more complicated. There are four
+ * possible modes, two of them we can group together:
+ *
+ * 1. Use the linear_id directly. Only used when there is no instancing.
+ *
+ * 2. Use the linear_id modulo a constant. This is used for per-vertex
+ * attributes with instancing enabled by making the constant equal
+ * padded_num_vertices. Because the modulus is always padded_num_vertices, this
+ * mode only supports a modulus that is a power of 2 times 1, 3, 5, 7, or 9.
+ * The shift field specifies the power of two, while the extra_flags field
+ * specifies the odd number. If shift = n and extra_flags = m, then the modulus
+ * is (2m + 1) * 2^n. As an example, if num_vertices = 70, then as computed
+ * above, padded_num_vertices = 9 * 2^3, so we should set extra_flags = 4 and
+ * shift = 3. Note that we must exactly follow the hardware algorithm used to
+ * get padded_num_vertices in order to correctly implement per-vertex
+ * attributes.
+ *
+ * 3. Divide the linear_id by a constant. In order to correctly implement
+ * instance divisors, we have to divide linear_id by padded_num_vertices times
+ * to user-specified divisor. So first we compute padded_num_vertices, again
+ * following the exact same algorithm that the hardware uses, then multiply it
+ * by the GL-level divisor to get the hardware-level divisor. This case is
+ * further divided into two more cases. If the hardware-level divisor is a
+ * power of two, then we just need to shift. The shift amount is specified by
+ * the shift field, so that the hardware-level divisor is just 2^shift.
+ *
+ * If it isn't a power of two, then we have to divide by an arbitrary integer.
+ * For that, we use the well-known technique of multiplying by an approximation
+ * of the inverse. The driver must compute the magic multiplier and shift
+ * amount, and then the hardware does the multiplication and shift. The
+ * hardware and driver also use the "round-down" optimization as described in
+ * http://ridiculousfish.com/files/faster_unsigned_division_by_constants.pdf.
+ * The hardware further assumes the multiplier is between 2^31 and 2^32, so the
+ * high bit is implicitly set to 1 even though it is set to 0 by the driver --
+ * presumably this simplifies the hardware multiplier a little. The hardware
+ * first multiplies linear_id by the multiplier and takes the high 32 bits,
+ * then applies the round-down correction if extra_flags = 1, then finally
+ * shifts right by the shift field.
+ *
+ * There are some differences between ridiculousfish's algorithm and the Mali
+ * hardware algorithm, which means that the reference code from ridiculousfish
+ * doesn't always produce the right constants. Mali does not use the pre-shift
+ * optimization, since that would make a hardware implementation slower (it
+ * would have to always do the pre-shift, multiply, and post-shift operations).
+ * It also forces the multplier to be at least 2^31, which means that the
+ * exponent is entirely fixed, so there is no trial-and-error. Altogether,
+ * given the divisor d, the algorithm the driver must follow is:
+ *
+ * 1. Set shift = floor(log2(d)).
+ * 2. Compute m = ceil(2^(shift + 32) / d) and e = 2^(shift + 32) % d.
+ * 3. If e <= 2^shift, then we need to use the round-down algorithm. Set
+ * magic_divisor = m - 1 and extra_flags = 1.
+ * 4. Otherwise, set magic_divisor = m and extra_flags = 0.
+ */
 
-/* TODO: I'm pretty sure this isn't really right in the presence of more
- * complicated metadata, like matrices or varyings */
-
-enum mali_attr_type {
-        MALI_ATYPE_PACKED = 1,
-        MALI_ATYPE_UNK1 = 1,
-        MALI_ATYPE_BYTE = 3,
-        MALI_ATYPE_SHORT = 4,
-        MALI_ATYPE_INT = 5,
-        MALI_ATYPE_GPVARYING = 6,
-        MALI_ATYPE_FLOAT = 7,
+enum mali_attr_mode {
+	MALI_ATTR_UNUSED = 0,
+	MALI_ATTR_LINEAR = 1,
+	MALI_ATTR_POT_DIVIDE = 2,
+	MALI_ATTR_MODULO = 3,
+	MALI_ATTR_NPOT_DIVIDE = 4,
 };
 
+union mali_attr {
+	/* This is used for actual attributes. */
+	struct {
+		/* The bottom 3 bits are the mode */
+		mali_ptr elements : 64 - 8;
+		u32 shift : 5;
+		u32 extra_flags : 3;
+		u32 stride;
+		u32 size;
+	};
+	/* The entry after an NPOT_DIVIDE entry has this format. It stores
+	 * extra information that wouldn't fit in a normal entry.
+	 */
+	struct {
+		u32 unk; /* = 0x20 */
+		u32 magic_divisor;
+		u32 zero;
+		/* This is the original, GL-level divisor. */
+		u32 divisor;
+	};
+} __attribute__((packed));
+
 struct mali_attr_meta {
         /* Vertex buffer index */
         u8 index;
 
-        u64 unknown1 : 14;
-
-        /* Part of the type specifier, anyway:
-         * 1: packed (with other encoding weirdness)
-         * 3: byte
-         * 4: short
-         * 5: int
-         * 6: used for float gl_Position varying?
-         * 7: half, float, packed
-         */
-
-        unsigned type : 3;
-
-        /* After MALI_POSITIVE, 4 for vec4, 1 for scalar, etc */
-        unsigned nr_components : 2;
-
-        /* Somewhat correlated to the opposite of not_normalised, or the opposite of is_half_float? */
-        unsigned unknown2 : 1;
-
-        /* If the type is a signed integer, is_int_signed is set. If the type
-         * is a half-float, it's also set. Otherwise, it is clear. */
-
-        unsigned is_int_signed : 1;
-
-        /* if `normalized` passed to VertexAttribPointer is clear */
-        unsigned not_normalised : 1;
+        unsigned unknown1 : 2;
+        unsigned swizzle : 12;
+        enum mali_format format : 8;
 
         /* Always observed to be zero at the moment */
         unsigned unknown3 : 2;
@@ -742,18 +1043,6 @@ struct bifrost_payload_fused {
 
 #define MALI_NEGATIVE(dim) (dim + 1)
 
-/* Used with channel swizzling */
-enum mali_channel {
-        MALI_CHANNEL_RED = 0,
-        MALI_CHANNEL_GREEN = 1,
-        MALI_CHANNEL_BLUE = 2,
-        MALI_CHANNEL_ALPHA = 3,
-        MALI_CHANNEL_ZERO = 4,
-        MALI_CHANNEL_ONE = 5,
-        MALI_CHANNEL_RESERVED_0 = 6,
-        MALI_CHANNEL_RESERVED_1 = 7,
-};
-
 /* Used with wrapping. Incomplete (this is a 4-bit field...) */
 
 enum mali_wrap_mode {
@@ -775,29 +1064,7 @@ struct mali_texture_format {
         unsigned bottom : 8;
         unsigned unk1 : 4;
 
-        /*
-         * 0: ushort_5_6_5
-         * 2: ushort_4_4_4_4
-         * 3: u8
-         * 4: u16
-         * 5: u32
-         * 7: float
-         */
-
-        unsigned component_size : 3;
-
-        unsigned nr_channels : 2;
-
-        /*
-         * 2: ushort_5_5_5_1, ushort_5_6_5
-         * 3: snorm
-         * 4: unsigned int
-         * 5: (unsigned) int / full-float
-         * 6: signed int / half-float
-         * 7: maybe also snorm related
-         */
-
-        unsigned typeA : 3;
+        enum mali_format format : 8;
 
         unsigned usage1 : 3;
         unsigned is_not_cubemap : 1;
@@ -826,10 +1093,7 @@ struct mali_texture_descriptor {
          * level swizzling, not the internal pixel-level swizzling which is
          * below OpenGL's reach */
 
-        enum mali_channel swizzle_r : 3;
-        enum mali_channel swizzle_g : 3;
-        enum mali_channel swizzle_b : 3;
-        enum mali_channel swizzle_a : 3;
+        unsigned swizzle : 12;
         unsigned swizzle_zero       : 20;
 
         uint32_t unknown5;
-- 
2.18.1


From 1f2ba583f411ee319a944c75ec2c4beb281dc833 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 00:31:58 +0000
Subject: [PATCH 02/16] mali_attr is now a union

---
 src/gallium/drivers/panfrost/pan_context.c             | 8 ++++----
 src/gallium/drivers/panfrost/pan_context.h             | 2 +-
 src/gallium/drivers/panfrost/pan_wallpaper.c           | 2 +-
 src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c | 4 ++--
 4 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 6aebaefede..b42df42bc1 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1017,8 +1017,8 @@ static void
 panfrost_emit_vertex_data(struct panfrost_context *ctx)
 {
         /* TODO: Only update the dirtied buffers */
-        struct mali_attr attrs[PIPE_MAX_ATTRIBS];
-        struct mali_attr varyings[PIPE_MAX_ATTRIBS];
+        union mali_attr attrs[PIPE_MAX_ATTRIBS];
+        union mali_attr varyings[PIPE_MAX_ATTRIBS];
 
         for (int i = 0; i < ctx->vertex_buffer_count; ++i) {
                 struct pipe_vertex_buffer *buf = &ctx->vertex_buffers[i];
@@ -1063,9 +1063,9 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
                 assert(ctx->varying_height < ctx->varying_mem.size);
         }
 
-        ctx->payload_vertex.postfix.attributes = panfrost_upload_transient(ctx, attrs, ctx->vertex_buffer_count * sizeof(struct mali_attr));
+        ctx->payload_vertex.postfix.attributes = panfrost_upload_transient(ctx, attrs, ctx->vertex_buffer_count * sizeof(union mali_attr));
 
-        mali_ptr varyings_p = panfrost_upload_transient(ctx, &varyings, ctx->vs->varyings.varying_buffer_count * sizeof(struct mali_attr));
+        mali_ptr varyings_p = panfrost_upload_transient(ctx, &varyings, ctx->vs->varyings.varying_buffer_count * sizeof(union mali_attr));
         ctx->payload_vertex.postfix.varyings = varyings_p;
         ctx->payload_tiler.postfix.varyings = varyings_p;
 }
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index f86de4e191..3b5d274378 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -172,7 +172,7 @@ struct panfrost_context {
 
         unsigned vertex_count;
 
-        struct mali_attr attributes[PIPE_MAX_ATTRIBS];
+        union mali_attr attributes[PIPE_MAX_ATTRIBS];
 
         unsigned varying_height;
 
diff --git a/src/gallium/drivers/panfrost/pan_wallpaper.c b/src/gallium/drivers/panfrost/pan_wallpaper.c
index a9ba3f00ea..d90383c5d4 100644
--- a/src/gallium/drivers/panfrost/pan_wallpaper.c
+++ b/src/gallium/drivers/panfrost/pan_wallpaper.c
@@ -221,7 +221,7 @@ panfrost_draw_wallpaper(struct pipe_context *pipe)
                 1.0, 1.0, 0.0, 0.0
         };
 
-        struct mali_attr varyings[1] = {
+        union mali_attr varyings[1] = {
                 {
                         .elements = panfrost_upload_transient(ctx, texture_coordinates, sizeof(texture_coordinates)) | 1,
                         .stride = sizeof(float) * 4,
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
index 80a5523937..bbc27bb570 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
@@ -624,7 +624,7 @@ panwrap_replay_attributes(const struct panwrap_mapped_memory *mem,
         /* Varyings in particular get duplicated between parts of the job */
         if (panwrap_deduplicate(mem, addr, prefix, job_no)) return;
 
-        struct mali_attr *attr = panwrap_fetch_gpu_mem(mem, addr, sizeof(struct mali_attr) * count);
+        union mali_attr *attr = panwrap_fetch_gpu_mem(mem, addr, sizeof(union mali_attr) * count);
 
         char base[128];
         snprintf(base, sizeof(base), "%s_data_%d%s", prefix, job_no, suffix);
@@ -679,7 +679,7 @@ panwrap_replay_attributes(const struct panwrap_mapped_memory *mem,
                 }
         }
 
-        panwrap_log("struct mali_attr %s_%d[] = {\n", prefix, job_no);
+        panwrap_log("union mali_attr %s_%d[] = {\n", prefix, job_no);
         panwrap_indent++;
 
         for (int i = 0; i < count; ++i) {
-- 
2.18.1


From bd93c6fe7672b1acdbb7dd6872c46e45b5b2860c Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 00:37:33 +0000
Subject: [PATCH 03/16] Manually apply panwrap changes (groan)

---
 .../panfrost/panwrap/panwrap-decoder.c        | 166 ++++++++++++++++--
 1 file changed, 148 insertions(+), 18 deletions(-)

diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
index bbc27bb570..d16870dc6b 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
@@ -215,6 +215,21 @@ panwrap_stencil_op_name(enum mali_stencil_op op)
 
 #undef DEFINE_CASE
 
+#define DEFINE_CASE(name) case MALI_ATTR_ ## name: return "MALI_ATTR_" #name
+static char *panwrap_attr_mode_name(enum mali_attr_mode mode)
+{
+	switch(mode) {
+	DEFINE_CASE(UNUSED);
+	DEFINE_CASE(LINEAR);
+	DEFINE_CASE(POT_DIVIDE);
+	DEFINE_CASE(MODULO);
+	DEFINE_CASE(NPOT_DIVIDE);
+	default: return "MALI_ATTR_UNUSED /* XXX: Unknown stencil op, check dump */";
+	}
+}
+
+#undef DEFINE_CASE
+
 #define DEFINE_CASE(name) case MALI_CHANNEL_## name: return "MALI_CHANNEL_" #name
 static char *
 panwrap_channel_name(enum mali_channel channel)
@@ -235,6 +250,95 @@ panwrap_channel_name(enum mali_channel channel)
 }
 #undef DEFINE_CASE
 
+#define DEFINE_CASE(name) case MALI_## name: return "MALI_" #name
+static char *panwrap_format_name(enum mali_format format)
+{
+	static char unk_format_str[5];
+
+	switch (format) {
+	DEFINE_CASE(RGB10_A2_UNORM);
+	DEFINE_CASE(RGB10_A2_SNORM);
+	DEFINE_CASE(RGB10_A2UI);
+	DEFINE_CASE(RGB10_A2I);
+	DEFINE_CASE(R32_FIXED);
+	DEFINE_CASE(RG32_FIXED);
+	DEFINE_CASE(RGB32_FIXED);
+	DEFINE_CASE(RGBA32_FIXED);
+	DEFINE_CASE(R11F_G11F_B10F);
+	DEFINE_CASE(VARYING_POS);
+	DEFINE_CASE(VARYING_DISCARD);
+
+	DEFINE_CASE(R8_SNORM);
+	DEFINE_CASE(R16_SNORM);
+	DEFINE_CASE(R32_SNORM);
+	DEFINE_CASE(RG8_SNORM);
+	DEFINE_CASE(RG16_SNORM);
+	DEFINE_CASE(RG32_SNORM);
+	DEFINE_CASE(RGB8_SNORM);
+	DEFINE_CASE(RGB16_SNORM);
+	DEFINE_CASE(RGB32_SNORM);
+	DEFINE_CASE(RGBA8_SNORM);
+	DEFINE_CASE(RGBA16_SNORM);
+	DEFINE_CASE(RGBA32_SNORM);
+
+	DEFINE_CASE(R8UI);
+	DEFINE_CASE(R16UI);
+	DEFINE_CASE(R32UI);
+	DEFINE_CASE(RG8UI);
+	DEFINE_CASE(RG16UI);
+	DEFINE_CASE(RG32UI);
+	DEFINE_CASE(RGB8UI);
+	DEFINE_CASE(RGB16UI);
+	DEFINE_CASE(RGB32UI);
+	DEFINE_CASE(RGBA8UI);
+	DEFINE_CASE(RGBA16UI);
+	DEFINE_CASE(RGBA32UI);
+
+	DEFINE_CASE(R8_UNORM);
+	DEFINE_CASE(R16_UNORM);
+	DEFINE_CASE(R32_UNORM);
+	DEFINE_CASE(R32F);
+	DEFINE_CASE(RG8_UNORM);
+	DEFINE_CASE(RG16_UNORM);
+	DEFINE_CASE(RG32_UNORM);
+	DEFINE_CASE(RG32F);
+	DEFINE_CASE(RGB8_UNORM);
+	DEFINE_CASE(RGB16_UNORM);
+	DEFINE_CASE(RGB32_UNORM);
+	DEFINE_CASE(RGB32F);
+	DEFINE_CASE(RGBA8_UNORM);
+	DEFINE_CASE(RGBA16_UNORM);
+	DEFINE_CASE(RGBA32_UNORM);
+	DEFINE_CASE(RGBA32F);
+
+	DEFINE_CASE(R8I);
+	DEFINE_CASE(R16I);
+	DEFINE_CASE(R32I);
+	DEFINE_CASE(RG8I);
+	DEFINE_CASE(R16F);
+	DEFINE_CASE(RG16I);
+	DEFINE_CASE(RG32I);
+	DEFINE_CASE(RG16F);
+	DEFINE_CASE(RGB8I);
+	DEFINE_CASE(RGB16I);
+	DEFINE_CASE(RGB32I);
+	DEFINE_CASE(RGB16F);
+	DEFINE_CASE(RGBA8I);
+	DEFINE_CASE(RGBA16I);
+	DEFINE_CASE(RGBA32I);
+	DEFINE_CASE(RGBA16F);
+
+	DEFINE_CASE(RGBA4);
+	DEFINE_CASE(RGBA8_2);
+	DEFINE_CASE(RGB10_A2_2);
+	default:
+	snprintf(unk_format_str, sizeof(unk_format_str), "0x%02x", format);
+	return unk_format_str;
+	}
+}
+
+#undef DEFINE_CASE
+
 #define DEFINE_CASE(name) case MALI_WRAP_## name: return "MALI_WRAP_" #name
 static char *
 panwrap_wrap_mode_name(enum mali_wrap_mode op)
@@ -630,7 +734,11 @@ panwrap_replay_attributes(const struct panwrap_mapped_memory *mem,
         snprintf(base, sizeof(base), "%s_data_%d%s", prefix, job_no, suffix);
 
         for (int i = 0; i < count; ++i) {
-                mali_ptr raw_elements = attr[i].elements & ~3;
+		enum mali_attr_mode mode = attr[i].elements & 7;
+		if (mode == MALI_ATTR_UNUSED)
+			continue;
+
+		mali_ptr raw_elements = attr[i].elements & ~7;
 
                 /* gl_VertexID and gl_InstanceID do not have elements to
                  * decode; we would crash if we tried */
@@ -686,11 +794,28 @@ panwrap_replay_attributes(const struct panwrap_mapped_memory *mem,
                 panwrap_log("{\n");
                 panwrap_indent++;
 
-                panwrap_prop("elements = (%s_%d_p) | %d", base, i, (int) (attr[i].elements & 3));
+
+		panwrap_prop("elements = (%s_%d_p) | %s", base, i, panwrap_attr_mode_name(attr[i].elements & 7));
+		panwrap_prop("shift = %d", attr[i].shift);
+		panwrap_prop("extra_flags = %d", attr[i].extra_flags);
                 panwrap_prop("stride = 0x%" PRIx32, attr[i].stride);
                 panwrap_prop("size = 0x%" PRIx32, attr[i].size);
                 panwrap_indent--;
                 panwrap_log("}, \n");
+
+		if ((attr[i].elements & 7) == MALI_ATTR_NPOT_DIVIDE) {
+			i++;
+			panwrap_log("{\n");
+			panwrap_indent++;
+			panwrap_prop("unk = 0x%x", attr[i].unk);
+			panwrap_prop("magic_divisor = 0x%08x", attr[i].magic_divisor);
+			if (attr[i].zero != 0)
+				panwrap_prop("zero = 0x%x /* XXX zero tripped */", attr[i].zero);
+			panwrap_prop("divisor = %d", attr[i].divisor);
+			panwrap_indent--;
+			panwrap_log("}, \n");
+		}
+
         }
 
         panwrap_indent--;
@@ -756,10 +881,21 @@ panwrap_replay_blend_equation(const struct mali_blend_equation *blend, const cha
 }
 
 static void
+panwrap_replay_swizzle(unsigned swizzle)
+{
+	panwrap_prop("swizzle = %s | (%s << 3) | (%s << 6) | (%s << 9)",
+			panwrap_channel_name((swizzle >> 0) & 0x7),
+			panwrap_channel_name((swizzle >> 3) & 0x7),
+			panwrap_channel_name((swizzle >> 6) & 0x7),
+			panwrap_channel_name((swizzle >> 9) & 0x7));
+}
+
+static int
 panwrap_replay_attribute_meta(int job_no, int count, const struct mali_vertex_tiler_postfix *v, bool varying, char *suffix)
 {
         char base[128];
         char *prefix = varying ? "varying" : "attribute";
+	unsigned max_index = 0;
         snprintf(base, sizeof(base), "%s_meta", prefix);
 
         panwrap_log("struct mali_attr_meta %s_%d%s[] = {\n", base, job_no, suffix);
@@ -778,15 +914,13 @@ panwrap_replay_attribute_meta(int job_no, int count, const struct mali_vertex_ti
                 panwrap_log("{\n");
                 panwrap_indent++;
                 panwrap_prop("index = %d", attr_meta->index);
-                panwrap_prop("type = %d", attr_meta->type);
-                panwrap_prop("nr_components = MALI_POSITIVE(%d)", MALI_NEGATIVE(attr_meta->nr_components));
 
-                /* TODO: Dissect correctly */
-                panwrap_prop("is_int_signed = %d", attr_meta->is_int_signed);
+		if (attr_meta->index > max_index)
+			max_index = attr_meta->index;
+		panwrap_replay_swizzle(attr_meta->swizzle);
+		panwrap_prop("format = %s", panwrap_format_name(attr_meta->format));
 
-                panwrap_prop("not_normalised = %d", attr_meta->not_normalised);
                 panwrap_prop("unknown1 = 0x%" PRIx64, (u64) attr_meta->unknown1);
-                panwrap_prop("unknown2 = 0x%" PRIx64, (u64) attr_meta->unknown2);
                 panwrap_prop("unknown3 = 0x%" PRIx64, (u64) attr_meta->unknown3);
                 panwrap_prop("src_offset = 0x%" PRIx64, (u64) attr_meta->src_offset);
                 panwrap_indent--;
@@ -798,6 +932,8 @@ panwrap_replay_attribute_meta(int job_no, int count, const struct mali_vertex_ti
         panwrap_log("};\n");
 
         TOUCH_LEN(attr_mem, p_orig, sizeof(struct mali_attr_meta) * count, base, job_no, true);
+
+        return max_index;
 }
 
 static void
@@ -1245,10 +1381,10 @@ panwrap_replay_vertex_tiler_postfix_pre(const struct mali_vertex_tiler_postfix *
         }
 
         if (p->attribute_meta) {
-                panwrap_replay_attribute_meta(job_no, attribute_count, p, false, suffix);
+                unsigned max_attr_index = panwrap_replay_attribute_meta(job_no, attribute_count, p, false, suffix);
 
                 attr_mem = panwrap_find_mapped_gpu_mem_containing(p->attributes);
-                panwrap_replay_attributes(attr_mem, p->attributes, job_no, suffix, attribute_count, false);
+                panwrap_replay_attributes(attr_mem, p->attributes, job_no, suffix, max_attr_index + 1, false);
         }
 
         /* Varyings are encoded like attributes but not actually sent; we just
@@ -1349,10 +1485,7 @@ panwrap_replay_vertex_tiler_postfix_pre(const struct mali_vertex_tiler_postfix *
 
                                         panwrap_prop("bottom = 0x%" PRIx32, f.bottom);
                                         panwrap_prop("unk1 = 0x%" PRIx32, f.unk1);
-                                        panwrap_prop("component_size = 0x%" PRIx32, f.component_size);
-                                        panwrap_prop("nr_channels = MALI_POSITIVE(%" PRId32 ")", f.nr_channels + 1);
-
-                                        panwrap_prop("typeA = %" PRId32, f.typeA);
+					panwrap_prop("format = %s", panwrap_format_name(f.format));
 
                                         panwrap_prop("usage1 = 0x%" PRIx32, f.usage1);
                                         panwrap_prop("is_not_cubemap = %" PRId32, f.is_not_cubemap);
@@ -1361,10 +1494,7 @@ panwrap_replay_vertex_tiler_postfix_pre(const struct mali_vertex_tiler_postfix *
                                         panwrap_indent--;
                                         panwrap_log("},\n");
 
-                                        panwrap_prop("swizzle_r = %s", panwrap_channel_name(t->swizzle_r));
-                                        panwrap_prop("swizzle_g = %s", panwrap_channel_name(t->swizzle_g));
-                                        panwrap_prop("swizzle_b = %s", panwrap_channel_name(t->swizzle_b));
-                                        panwrap_prop("swizzle_a = %s", panwrap_channel_name(t->swizzle_a));
+					panwrap_replay_swizzle(t->swizzle);
 
                                         if (t->swizzle_zero) {
                                                 /* Shouldn't happen */
-- 
2.18.1


From 21d351e9dcd19d012567e030bad6fdff032d6a6f Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 00:38:32 +0000
Subject: [PATCH 04/16] Don't deal with wallpaper regressions

---
 src/gallium/drivers/panfrost/pan_wallpaper.c | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_wallpaper.c b/src/gallium/drivers/panfrost/pan_wallpaper.c
index d90383c5d4..dceb6467c4 100644
--- a/src/gallium/drivers/panfrost/pan_wallpaper.c
+++ b/src/gallium/drivers/panfrost/pan_wallpaper.c
@@ -137,6 +137,8 @@ panfrost_draw_wallpaper(struct pipe_context *pipe)
         /* Disable wallpapering for now */
         return;
 
+#if 0
+
         /* Setup payload for elided quad. TODO: Refactor draw_vbo so this can
          * be a little more DRY */
 
@@ -193,14 +195,12 @@ panfrost_draw_wallpaper(struct pipe_context *pipe)
          * shader epilogue for more context */
 
         float implied_position_varying[] = {
-#if 0
                 /* The following is correct for scissored clears whose scissor deals with cutoff appropriately */
 
-                -1.0, -1.0,        0.0, 1.0,
-                -1.0, 65535.0,     0.0, 1.0,
-                65536.0, 1.0,      0.0, 1.0,
-                65536.0, 65536.0,  0.0, 1.0
-#endif
+//                -1.0, -1.0,        0.0, 1.0,
+//                -1.0, 65535.0,     0.0, 1.0,
+//                65536.0, 1.0,      0.0, 1.0,
+//                65536.0, 65536.0,  0.0, 1.0
 
                 /* The following output is correct for a fullscreen quad with screen size 2048x1600 */
                 0.0, 0.0, 0.0, 1.0,
@@ -268,4 +268,5 @@ panfrost_draw_wallpaper(struct pipe_context *pipe)
         /* Cleanup */
         panfrost_disable_wallpaper_program(pipe);
         ctx->payload_tiler.postfix.varying_meta = saved_varying_meta;
+#endif
 }
-- 
2.18.1


From 7bdc3372860b4f46b70d44588da1974acb35f002 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 00:44:50 +0000
Subject: [PATCH 05/16] Update texture swizzle to new headers

---
 src/gallium/drivers/panfrost/pan_context.c | 22 +++++++++++++++++-----
 1 file changed, 17 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index b42df42bc1..900533e3c0 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -641,7 +641,7 @@ panfrost_emit_tiler_payload(struct panfrost_context *ctx)
 }
 
 static unsigned
-panfrost_translate_texture_swizzle(enum pipe_swizzle s)
+panfrost_translate_swizzle(enum pipe_swizzle s)
 {
         switch (s) {
         case PIPE_SWIZZLE_X:
@@ -668,6 +668,21 @@ panfrost_translate_texture_swizzle(enum pipe_swizzle s)
         }
 }
 
+/* Translate a Gallium swizzle quad to a 12-bit Mali swizzle code */
+
+static unsigned
+panfrost_translate_swizzle_4(unsigned char swizzle[4])
+{
+        unsigned out = 0;
+
+        for (unsigned i = 0; i < 4; ++i) {
+                unsigned translated = panfrost_translate_swizzle(swizzle[i]);
+                out |= (translated << (3*i));
+        }
+
+        return out;
+}
+
 static unsigned
 translate_tex_wrap(enum pipe_tex_wrap w)
 {
@@ -2198,10 +2213,7 @@ panfrost_create_sampler_view(
                         .usage2 = prsrc->has_afbc ? 0x1c : (prsrc->tiled ? 0x11 : 0x12),
                 },
 
-                .swizzle_r = panfrost_translate_texture_swizzle(composed_swizzle[0]),
-                .swizzle_g = panfrost_translate_texture_swizzle(composed_swizzle[1]),
-                .swizzle_b = panfrost_translate_texture_swizzle(composed_swizzle[2]),
-                .swizzle_a = panfrost_translate_texture_swizzle(composed_swizzle[3]),
+                .swizzle = panfrost_translate_swizzle_4(composed_swizzle)
         };
 
         /* TODO: Other base levels require adjusting dimensions / level numbers / etc */
-- 
2.18.1


From 174bc0a8e1db6bb88adef136574795abaec1ae62 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 01:00:11 +0000
Subject: [PATCH 06/16] Handle attribute swizzles

---
 src/gallium/drivers/panfrost/pan_assemble.c | 12 ++++++---
 src/gallium/drivers/panfrost/pan_context.c  | 28 +++++++++++++--------
 src/gallium/drivers/panfrost/pan_context.h  |  3 +++
 3 files changed, 29 insertions(+), 14 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_assemble.c b/src/gallium/drivers/panfrost/pan_assemble.c
index e20664367d..cef20d6992 100644
--- a/src/gallium/drivers/panfrost/pan_assemble.c
+++ b/src/gallium/drivers/panfrost/pan_assemble.c
@@ -127,13 +127,15 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
                 varyings->varyings_stride[1] = 4 * sizeof(float);
 
                 /* Setup gl_Position and its weirdo analogue */
+                unsigned default_vec4_swizzle = panfrost_get_default_swizzle(4);
 
                 struct mali_attr_meta position_meta = {
                         .index = 1,
                         .type = 6, /* gl_Position */
                         .nr_components = MALI_POSITIVE(4),
                         .is_int_signed = 1,
-                        .unknown1 = 0x1a22
+                        .unknown1 = 0x2,
+                        .swizzle = default_vec4_swizzle,
                 };
 
                 struct mali_attr_meta position_meta_prime = {
@@ -141,7 +143,10 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
                         .type = 7, /* float */
                         .nr_components = MALI_POSITIVE(4),
                         .is_int_signed = 1,
-                        .unknown1 = 0x2490
+
+                        /* TODO: Wat? yyyy swizzle? */
+                        .swizzle = 0x249,
+                        .unknown1 = 0x0,
                 };
 
                 varyings->vertex_only_varyings[0] = position_meta;
@@ -155,7 +160,8 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
                                 .type = 7, /* float */
                                 .nr_components = MALI_POSITIVE(4),
                                 .not_normalised = 1,
-                                .unknown1 = 0x1a22,
+                                .swizzle = default_vec4_swizzle,
+                                .unknown1 = 0x2,
 
                                 /* mediump => half-floats */
                                 .is_int_signed = 1,
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 900533e3c0..fd5ba547ef 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1851,6 +1851,21 @@ panfrost_bind_rasterizer_state(
         ctx->dirty |= PAN_DIRTY_RASTERIZER;
 }
 
+/* Construct a default swizzle based on the number of components */
+
+unsigned
+panfrost_get_default_swizzle(unsigned components)
+{
+        unsigned char default_swizzles[4][4] = {
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_0, PIPE_SWIZZLE_0, PIPE_SWIZZLE_1},
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_0, PIPE_SWIZZLE_1},
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_1},
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_W},
+        };
+
+        return panfrost_translate_swizzle_4(default_swizzles[components]);
+}
+
 static void *
 panfrost_create_vertex_elements_state(
         struct pipe_context *pctx,
@@ -1908,17 +1923,8 @@ panfrost_create_vertex_elements_state(
                 so->hw[i].nr_components = MALI_POSITIVE(desc->nr_channels);
                 so->nr_components[i] = desc->nr_channels;
 
-                /* The meaning of these magic values is unclear at the moment,
-                 * but likely has to do with how attributes are padded */
-
-                unsigned unknown1_for_components[4] = {
-                        0x2c82, /* float */
-                        0x2c22, /* vec2 */
-                        0x2a22, /* vec3 */
-                        0x1a22, /* vec4 */
-                };
-
-                so->hw[i].unknown1 = unknown1_for_components[desc->nr_channels - 1];
+                so->hw[i].unknown1 = 0x2;
+                so->hw[i].swizzle = panfrost_get_default_swizzle(desc->nr_channels);
 
                 so->hw[i].unknown2 = 0x1;
 
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 3b5d274378..3e0619983c 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -391,4 +391,7 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data);
 struct panfrost_transfer
 panfrost_vertex_tiler_job(struct panfrost_context *ctx, bool is_tiler, bool is_elided_tiler);
 
+unsigned
+panfrost_get_default_swizzle(unsigned components);
+
 #endif
-- 
2.18.1


From 46ad311f290161885be6e313a8e6a7edf800a2b2 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 01:17:58 +0000
Subject: [PATCH 07/16] Update attributes to use mali_format

---
 src/gallium/drivers/panfrost/pan_context.c | 113 ++++++++++++++-------
 1 file changed, 76 insertions(+), 37 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index fd5ba547ef..c91f80ae29 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1866,66 +1866,105 @@ panfrost_get_default_swizzle(unsigned components)
         return panfrost_translate_swizzle_4(default_swizzles[components]);
 }
 
-static void *
-panfrost_create_vertex_elements_state(
-        struct pipe_context *pctx,
-        unsigned num_elements,
-        const struct pipe_vertex_element *elements)
+static unsigned
+panfrost_translate_channel_width(unsigned size)
 {
-        struct panfrost_vertex_state *so = CALLOC_STRUCT(panfrost_vertex_state);
+        switch (size) {
+                case 8:
+                        return MALI_CHANNEL_8;
+                case 16:
+                        return MALI_CHANNEL_16;
+                case 32:
+                        return MALI_CHANNEL_32;
+                default:
+                        assert(0);
+                        return 0;
+        }
+}
 
-        so->num_elements = num_elements;
-        memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
+static unsigned
+panfrost_translate_channel_type(unsigned type, unsigned size, bool norm) {
+        switch (type) {
+                case UTIL_FORMAT_TYPE_UNSIGNED:
+                        return norm ? MALI_FORMAT_UNORM : MALI_FORMAT_UINT;
 
-        for (int i = 0; i < num_elements; ++i) {
-                so->hw[i].index = elements[i].vertex_buffer_index;
+                case UTIL_FORMAT_TYPE_SIGNED:
+                        return norm ? MALI_FORMAT_SNORM : MALI_FORMAT_SINT;
 
-                enum pipe_format fmt = elements[i].src_format;
-                const struct util_format_description *desc = util_format_description(fmt);
-                struct util_format_channel_description chan = desc->channel[0];
+                case UTIL_FORMAT_TYPE_FLOAT:
+                        if (size == 16) {
+                                /* With FLOAT, fp16 */
+                                return MALI_FORMAT_SINT;
+                        } else if (size == 32) {
+                                /* With FLOAT< fp32 */
+                                return MALI_FORMAT_UNORM;
+                        } else {
+                                assert(0);
+                                return 0;
+                        }
 
-                int type = 0;
+                default:
+                        assert(0);
+                        return 0;
+        }
+}
+
+/* Constructs a mali_format satisfying the specified Gallium format
+ * description */
+
+static enum mali_format
+panfrost_find_format(const struct util_format_description *desc)
+{
+        /* Formats must match in channel count */
+        assert(desc->nr_channels >= 1 && desc->nr_channels <= 4);
+        unsigned format = MALI_NR_CHANNELS(desc->nr_channels);
 
-                switch (chan.type) {
+        struct util_format_channel_description chan = desc->channel[0];
+
+        switch (chan.type) {
                 case UTIL_FORMAT_TYPE_UNSIGNED:
                 case UTIL_FORMAT_TYPE_SIGNED:
-                        if (chan.size == 8)
-                                type = MALI_ATYPE_BYTE;
-                        else if (chan.size == 16)
-                                type = MALI_ATYPE_SHORT;
-                        else if (chan.size == 32)
-                                type = MALI_ATYPE_INT;
-                        else {
-                                printf("BAD INT SIZE %d\n", chan.size);
-                                assert(0);
-                        }
+                        /* Channel width */
+                        format |= panfrost_translate_channel_width(chan.size);
 
+                        /* Channel type */
+                        format |= panfrost_translate_channel_type(chan.type, chan.size, chan.normalized);
                         break;
 
                 case UTIL_FORMAT_TYPE_FLOAT:
-                        type = MALI_ATYPE_FLOAT;
+                        format |= MALI_CHANNEL_FLOAT;
+                        format |= panfrost_translate_channel_type(chan.type, chan.size, chan.normalized);
                         break;
 
                 default:
-                        printf("Unknown atype %d\n", chan.type);
                         assert(0);
-                }
+                        break;
+        }
 
-                so->hw[i].type = type;
-                so->hw[i].not_normalised = !chan.normalized;
+        return (enum mali_format) format;
+}
+
+static void *
+panfrost_create_vertex_elements_state(
+        struct pipe_context *pctx,
+        unsigned num_elements,
+        const struct pipe_vertex_element *elements)
+{
+        struct panfrost_vertex_state *so = CALLOC_STRUCT(panfrost_vertex_state);
 
-                /* Bit used for both signed/unsigned and full/half designation */
-                so->hw[i].is_int_signed =
-                        (chan.type == UTIL_FORMAT_TYPE_SIGNED) ? 1 :
-                        (chan.type == UTIL_FORMAT_TYPE_FLOAT && chan.size != 32) ? 1 :
-                        0;
+        so->num_elements = num_elements;
+        memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
 
-                so->hw[i].nr_components = MALI_POSITIVE(desc->nr_channels);
-                so->nr_components[i] = desc->nr_channels;
+        for (int i = 0; i < num_elements; ++i) {
+                so->hw[i].index = elements[i].vertex_buffer_index;
 
+                enum pipe_format fmt = elements[i].src_format;
+                const struct util_format_description *desc = util_format_description(fmt);
                 so->hw[i].unknown1 = 0x2;
                 so->hw[i].swizzle = panfrost_get_default_swizzle(desc->nr_channels);
 
+                so->hw[i].format = panfrost_find_format(desc);
+
                 so->hw[i].unknown2 = 0x1;
 
                 /* The field itself should probably be shifted over */
-- 
2.18.1


From f058562d631485e3d3bd2c5de7e0544006cc83f3 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 01:55:22 +0000
Subject: [PATCH 08/16] Refactor to use pan_format file

---
 src/gallium/drivers/panfrost/meson.build   |   1 +
 src/gallium/drivers/panfrost/pan_context.c | 137 +----------------
 src/gallium/drivers/panfrost/pan_format.c  | 166 +++++++++++++++++++++
 src/gallium/drivers/panfrost/pan_format.h  |  42 ++++++
 4 files changed, 210 insertions(+), 136 deletions(-)
 create mode 100644 src/gallium/drivers/panfrost/pan_format.c
 create mode 100644 src/gallium/drivers/panfrost/pan_format.h

diff --git a/src/gallium/drivers/panfrost/meson.build b/src/gallium/drivers/panfrost/meson.build
index 3348d7dd87..28a137ec0b 100644
--- a/src/gallium/drivers/panfrost/meson.build
+++ b/src/gallium/drivers/panfrost/meson.build
@@ -36,6 +36,7 @@ files_panfrost = files(
   'pan_nondrm.c',
   'pan_allocate.c',
   'pan_assemble.c',
+  'pan_format.c',
   'pan_swizzle.c',
   'pan_blending.c',
   'pan_blend_shaders.c',
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index c91f80ae29..6aa4c73639 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -29,6 +29,7 @@
 
 #include "pan_context.h"
 #include "pan_swizzle.h"
+#include "pan_format.h"
 
 #include "util/macros.h"
 #include "util/u_format.h"
@@ -640,49 +641,6 @@ panfrost_emit_tiler_payload(struct panfrost_context *ctx)
         memcpy(&ctx->payload_tiler, &payload_1, sizeof(payload_1));
 }
 
-static unsigned
-panfrost_translate_swizzle(enum pipe_swizzle s)
-{
-        switch (s) {
-        case PIPE_SWIZZLE_X:
-                return MALI_CHANNEL_RED;
-
-        case PIPE_SWIZZLE_Y:
-                return MALI_CHANNEL_GREEN;
-
-        case PIPE_SWIZZLE_Z:
-                return MALI_CHANNEL_BLUE;
-
-        case PIPE_SWIZZLE_W:
-                return MALI_CHANNEL_ALPHA;
-
-        case PIPE_SWIZZLE_0:
-                return MALI_CHANNEL_ZERO;
-
-        case PIPE_SWIZZLE_1:
-                return MALI_CHANNEL_ONE;
-
-        default:
-                assert(0);
-                return 0;
-        }
-}
-
-/* Translate a Gallium swizzle quad to a 12-bit Mali swizzle code */
-
-static unsigned
-panfrost_translate_swizzle_4(unsigned char swizzle[4])
-{
-        unsigned out = 0;
-
-        for (unsigned i = 0; i < 4; ++i) {
-                unsigned translated = panfrost_translate_swizzle(swizzle[i]);
-                out |= (translated << (3*i));
-        }
-
-        return out;
-}
-
 static unsigned
 translate_tex_wrap(enum pipe_tex_wrap w)
 {
@@ -1851,99 +1809,6 @@ panfrost_bind_rasterizer_state(
         ctx->dirty |= PAN_DIRTY_RASTERIZER;
 }
 
-/* Construct a default swizzle based on the number of components */
-
-unsigned
-panfrost_get_default_swizzle(unsigned components)
-{
-        unsigned char default_swizzles[4][4] = {
-                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_0, PIPE_SWIZZLE_0, PIPE_SWIZZLE_1},
-                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_0, PIPE_SWIZZLE_1},
-                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_1},
-                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_W},
-        };
-
-        return panfrost_translate_swizzle_4(default_swizzles[components]);
-}
-
-static unsigned
-panfrost_translate_channel_width(unsigned size)
-{
-        switch (size) {
-                case 8:
-                        return MALI_CHANNEL_8;
-                case 16:
-                        return MALI_CHANNEL_16;
-                case 32:
-                        return MALI_CHANNEL_32;
-                default:
-                        assert(0);
-                        return 0;
-        }
-}
-
-static unsigned
-panfrost_translate_channel_type(unsigned type, unsigned size, bool norm) {
-        switch (type) {
-                case UTIL_FORMAT_TYPE_UNSIGNED:
-                        return norm ? MALI_FORMAT_UNORM : MALI_FORMAT_UINT;
-
-                case UTIL_FORMAT_TYPE_SIGNED:
-                        return norm ? MALI_FORMAT_SNORM : MALI_FORMAT_SINT;
-
-                case UTIL_FORMAT_TYPE_FLOAT:
-                        if (size == 16) {
-                                /* With FLOAT, fp16 */
-                                return MALI_FORMAT_SINT;
-                        } else if (size == 32) {
-                                /* With FLOAT< fp32 */
-                                return MALI_FORMAT_UNORM;
-                        } else {
-                                assert(0);
-                                return 0;
-                        }
-
-                default:
-                        assert(0);
-                        return 0;
-        }
-}
-
-/* Constructs a mali_format satisfying the specified Gallium format
- * description */
-
-static enum mali_format
-panfrost_find_format(const struct util_format_description *desc)
-{
-        /* Formats must match in channel count */
-        assert(desc->nr_channels >= 1 && desc->nr_channels <= 4);
-        unsigned format = MALI_NR_CHANNELS(desc->nr_channels);
-
-        struct util_format_channel_description chan = desc->channel[0];
-
-        switch (chan.type) {
-                case UTIL_FORMAT_TYPE_UNSIGNED:
-                case UTIL_FORMAT_TYPE_SIGNED:
-                        /* Channel width */
-                        format |= panfrost_translate_channel_width(chan.size);
-
-                        /* Channel type */
-                        format |= panfrost_translate_channel_type(chan.type, chan.size, chan.normalized);
-                        break;
-
-                case UTIL_FORMAT_TYPE_FLOAT:
-                        format |= MALI_CHANNEL_FLOAT;
-                        format |= panfrost_translate_channel_type(chan.type, chan.size, chan.normalized);
-                        break;
-
-                default:
-                        assert(0);
-                        break;
-        }
-
-        return (enum mali_format) format;
-}
-
 static void *
 panfrost_create_vertex_elements_state(
         struct pipe_context *pctx,
diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
new file mode 100644
index 0000000000..b6005df47a
--- /dev/null
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -0,0 +1,166 @@
+/*
+ * © Copyright 2018 Alyssa Rosenzweig
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#include "pan_format.h"
+#include "util/u_format.h"
+
+/* Construct a default swizzle based on the number of components */
+
+static unsigned
+panfrost_translate_swizzle(enum pipe_swizzle s)
+{
+        switch (s) {
+        case PIPE_SWIZZLE_X:
+                return MALI_CHANNEL_RED;
+
+        case PIPE_SWIZZLE_Y:
+                return MALI_CHANNEL_GREEN;
+
+        case PIPE_SWIZZLE_Z:
+                return MALI_CHANNEL_BLUE;
+
+        case PIPE_SWIZZLE_W:
+                return MALI_CHANNEL_ALPHA;
+
+        case PIPE_SWIZZLE_0:
+                return MALI_CHANNEL_ZERO;
+
+        case PIPE_SWIZZLE_1:
+                return MALI_CHANNEL_ONE;
+
+        default:
+                assert(0);
+                return 0;
+        }
+}
+
+/* Translate a Gallium swizzle quad to a 12-bit Mali swizzle code */
+
+unsigned
+panfrost_translate_swizzle_4(unsigned char swizzle[4])
+{
+        unsigned out = 0;
+
+        for (unsigned i = 0; i < 4; ++i) {
+                unsigned translated = panfrost_translate_swizzle(swizzle[i]);
+                out |= (translated << (3*i));
+        }
+
+        return out;
+}
+
+
+
+unsigned
+panfrost_get_default_swizzle(unsigned components)
+{
+        unsigned char default_swizzles[4][4] = {
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_0, PIPE_SWIZZLE_0, PIPE_SWIZZLE_1},
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_0, PIPE_SWIZZLE_1},
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_1},
+                {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_W},
+        };
+
+        return panfrost_translate_swizzle_4(default_swizzles[components]);
+}
+
+static unsigned
+panfrost_translate_channel_width(unsigned size)
+{
+        switch (size) {
+                case 8:
+                        return MALI_CHANNEL_8;
+                case 16:
+                        return MALI_CHANNEL_16;
+                case 32:
+                        return MALI_CHANNEL_32;
+                default:
+                        assert(0);
+                        return 0;
+        }
+}
+
+static unsigned
+panfrost_translate_channel_type(unsigned type, unsigned size, bool norm) {
+        switch (type) {
+                case UTIL_FORMAT_TYPE_UNSIGNED:
+                        return norm ? MALI_FORMAT_UNORM : MALI_FORMAT_UINT;
+
+                case UTIL_FORMAT_TYPE_SIGNED:
+                        return norm ? MALI_FORMAT_SNORM : MALI_FORMAT_SINT;
+
+                case UTIL_FORMAT_TYPE_FLOAT:
+                        if (size == 16) {
+                                /* With FLOAT, fp16 */
+                                return MALI_FORMAT_SINT;
+                        } else if (size == 32) {
+                                /* With FLOAT< fp32 */
+                                return MALI_FORMAT_UNORM;
+                        } else {
+                                assert(0);
+                                return 0;
+                        }
+
+                default:
+                        assert(0);
+                        return 0;
+        }
+}
+
+/* Constructs a mali_format satisfying the specified Gallium format
+ * description */
+
+enum mali_format
+panfrost_find_format(const struct util_format_description *desc)
+{
+        /* Formats must match in channel count */
+        assert(desc->nr_channels >= 1 && desc->nr_channels <= 4);
+        unsigned format = MALI_NR_CHANNELS(desc->nr_channels);
+
+        struct util_format_channel_description chan = desc->channel[0];
+
+        switch (chan.type) {
+                case UTIL_FORMAT_TYPE_UNSIGNED:
+                case UTIL_FORMAT_TYPE_SIGNED:
+                        /* Channel width */
+                        format |= panfrost_translate_channel_width(chan.size);
+
+                        /* Channel type */
+                        format |= panfrost_translate_channel_type(chan.type, chan.size, chan.normalized);
+                        break;
+
+                case UTIL_FORMAT_TYPE_FLOAT:
+                        format |= MALI_CHANNEL_FLOAT;
+                        format |= panfrost_translate_channel_type(chan.type, chan.size, chan.normalized);
+                        break;
+
+                default:
+                        assert(0);
+                        break;
+        }
+
+        return (enum mali_format) format;
+}
+
+
diff --git a/src/gallium/drivers/panfrost/pan_format.h b/src/gallium/drivers/panfrost/pan_format.h
new file mode 100644
index 0000000000..db74088ec1
--- /dev/null
+++ b/src/gallium/drivers/panfrost/pan_format.h
@@ -0,0 +1,42 @@
+/*
+ * © Copyright 2018 Alyssa Rosenzweig
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#ifndef __PAN_FORMAT_H__
+#define __PAN_FORMAT_H__
+
+#include "pan_context.h"
+#include "util/u_format.h"
+
+unsigned
+panfrost_translate_swizzle_4(unsigned char swizzle[4]);
+
+unsigned
+panfrost_get_default_swizzle(unsigned components);
+
+enum mali_format
+panfrost_find_format(const struct util_format_description *desc);
+
+#endif
+
+
-- 
2.18.1


From 5b5860e19d6a65c9401e10725ecf861104967984 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 02:10:01 +0000
Subject: [PATCH 09/16] Hardcode formats for varyings

---
 src/gallium/drivers/panfrost/pan_assemble.c | 23 ++++++---------------
 src/gallium/drivers/panfrost/pan_context.c  |  2 --
 src/gallium/drivers/panfrost/pan_format.c   |  1 -
 3 files changed, 6 insertions(+), 20 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_assemble.c b/src/gallium/drivers/panfrost/pan_assemble.c
index cef20d6992..0792619d5c 100644
--- a/src/gallium/drivers/panfrost/pan_assemble.c
+++ b/src/gallium/drivers/panfrost/pan_assemble.c
@@ -131,18 +131,15 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
 
                 struct mali_attr_meta position_meta = {
                         .index = 1,
-                        .type = 6, /* gl_Position */
-                        .nr_components = MALI_POSITIVE(4),
-                        .is_int_signed = 1,
-                        .unknown1 = 0x2,
+                        .format = MALI_VARYING_POS,
+
                         .swizzle = default_vec4_swizzle,
+                        .unknown1 = 0x2,
                 };
 
                 struct mali_attr_meta position_meta_prime = {
-                        .index = 0,
-                        .type = 7, /* float */
-                        .nr_components = MALI_POSITIVE(4),
-                        .is_int_signed = 1,
+                        .index = 1,
+                        .format = MALI_RGBA16F,
 
                         /* TODO: Wat? yyyy swizzle? */
                         .swizzle = 0x249,
@@ -157,21 +154,13 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
                 for (int i = 0; i < varying_count; ++i) {
                         struct mali_attr_meta vec4_varying_meta = {
                                 .index = 0,
-                                .type = 7, /* float */
-                                .nr_components = MALI_POSITIVE(4),
-                                .not_normalised = 1,
+                                .format = MALI_RGBA16F,
                                 .swizzle = default_vec4_swizzle,
                                 .unknown1 = 0x2,
 
-                                /* mediump => half-floats */
-                                .is_int_signed = 1,
-
                                 /* Set offset to keep everything back-to-back in
                                  * the same buffer */
                                 .src_offset = 8 * i,
-#ifdef T6XX
-                                .unknown2 = 1,
-#endif
                         };
 
                         varyings->varyings[i] = vec4_varying_meta;
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 6aa4c73639..1f040e710d 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1830,8 +1830,6 @@ panfrost_create_vertex_elements_state(
 
                 so->hw[i].format = panfrost_find_format(desc);
 
-                so->hw[i].unknown2 = 0x1;
-
                 /* The field itself should probably be shifted over */
                 so->hw[i].src_offset = elements[i].src_offset;
         }
diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index b6005df47a..aa58f9d5c9 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -23,7 +23,6 @@
  */
 
 #include "pan_format.h"
-#include "util/u_format.h"
 
 /* Construct a default swizzle based on the number of components */
 
-- 
2.18.1


From 3951cb80b0bb4b60e396fcb9b51a039f14ca9027 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 02:12:30 +0000
Subject: [PATCH 10/16] Update texture formats

---
 src/gallium/drivers/panfrost/pan_context.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 1f040e710d..ab7ab49d7b 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2098,6 +2098,8 @@ panfrost_create_sampler_view(
 
         util_format_compose_swizzles(desc->swizzle, desc_swizzle, composed_swizzle);
 
+        enum mali_format format = panfrost_find_format(desc);
+
         struct mali_texture_descriptor texture_descriptor = {
                 .width = MALI_POSITIVE(texture->width0),
                 .height = MALI_POSITIVE(texture->height0),
@@ -2107,9 +2109,12 @@ panfrost_create_sampler_view(
                 .format = {
                         .bottom = alpha_only ? 0x24 : ((depth ? 0x20 : 0x88)),
                         .unk1 = alpha_only ? 0x1 : (has_alpha ? 0x6 : 0xb),
+#if 0
                         .component_size = depth ? 0x5 : 0x3,
                         .nr_channels = MALI_POSITIVE((depth ? 2 : bytes_per_pixel)),
                         .typeA = depth ? 2 : 5,
+#endif
+                        .format = format,
 
                         .usage1 = 0x0,
                         .is_not_cubemap = 1,
-- 
2.18.1


From 7e384f7b1d752534fbadc61f177b5b34ee7973cc Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 04:27:55 +0000
Subject: [PATCH 11/16] Fixes to get the branch to actually work

---
 src/gallium/drivers/panfrost/pan_context.c | 3 +++
 src/gallium/drivers/panfrost/pan_format.c  | 3 ++-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index ab7ab49d7b..453391d5e6 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2098,6 +2098,9 @@ panfrost_create_sampler_view(
 
         util_format_compose_swizzles(desc->swizzle, desc_swizzle, composed_swizzle);
 
+        /* XXX: Temporary hack for Kodi */
+        composed_swizzle[3] = PIPE_SWIZZLE_W;
+
         enum mali_format format = panfrost_find_format(desc);
 
         struct mali_texture_descriptor texture_descriptor = {
diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index aa58f9d5c9..ecfe7e680d 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -81,7 +81,8 @@ panfrost_get_default_swizzle(unsigned components)
                 {PIPE_SWIZZLE_X, PIPE_SWIZZLE_Y, PIPE_SWIZZLE_Z, PIPE_SWIZZLE_W},
         };
 
-        return panfrost_translate_swizzle_4(default_swizzles[components]);
+        assert(components >= 1 && components <= 4);
+        return panfrost_translate_swizzle_4(default_swizzles[components - 1]);
 }
 
 static unsigned
-- 
2.18.1


From afeee1f2b160b297f66dde508834c6a68ffc7ebd Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 04:51:18 +0000
Subject: [PATCH 12/16] Handle Z32_UNORM (fixes -brefract)

---
 .../drivers/panfrost/include/panfrost-job.h   |  1 +
 src/gallium/drivers/panfrost/pan_format.c     | 19 +++++++++++++++----
 .../panfrost/panwrap/panwrap-decoder.c        |  1 +
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/panfrost/include/panfrost-job.h b/src/gallium/drivers/panfrost/include/panfrost-job.h
index ad86cf01cd..09eded625e 100644
--- a/src/gallium/drivers/panfrost/include/panfrost-job.h
+++ b/src/gallium/drivers/panfrost/include/panfrost-job.h
@@ -310,6 +310,7 @@ enum mali_format {
 	MALI_RGB10_A2_SNORM = MALI_FORMAT_SPECIAL | 0x5,
 	MALI_RGB10_A2UI     = MALI_FORMAT_SPECIAL | 0x7,
 	MALI_RGB10_A2I      = MALI_FORMAT_SPECIAL | 0x9,
+        MALI_Z32_UNORM      = MALI_FORMAT_SPECIAL | 0xD,
 	MALI_R32_FIXED      = MALI_FORMAT_SPECIAL | 0x11,
 	MALI_RG32_FIXED     = MALI_FORMAT_SPECIAL | 0x12,
 	MALI_RGB32_FIXED    = MALI_FORMAT_SPECIAL | 0x13,
diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index ecfe7e680d..91de94e11b 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -69,8 +69,6 @@ panfrost_translate_swizzle_4(unsigned char swizzle[4])
         return out;
 }
 
-
-
 unsigned
 panfrost_get_default_swizzle(unsigned components)
 {
@@ -134,12 +132,25 @@ panfrost_translate_channel_type(unsigned type, unsigned size, bool norm) {
 enum mali_format
 panfrost_find_format(const struct util_format_description *desc)
 {
+        struct util_format_channel_description chan = desc->channel[0];
+
+        /* First check for depth/stencil, which is special-cased at the
+         * moment */
+
+        if (desc->colorspace == UTIL_FORMAT_COLORSPACE_ZS) {
+                /* Make sure we know how to deal with it */
+                assert(chan.type == UTIL_FORMAT_TYPE_UNSIGNED);
+                assert(chan.size == 32);
+                assert(desc->nr_channels == 1);
+                assert(desc->swizzle[0] == 0 /* Z */);
+
+                return MALI_Z32_UNORM;
+        }
+
         /* Formats must match in channel count */
         assert(desc->nr_channels >= 1 && desc->nr_channels <= 4);
         unsigned format = MALI_NR_CHANNELS(desc->nr_channels);
 
-        struct util_format_channel_description chan = desc->channel[0];
-
         switch (chan.type) {
                 case UTIL_FORMAT_TYPE_UNSIGNED:
                 case UTIL_FORMAT_TYPE_SIGNED:
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
index d16870dc6b..a9dc0840c7 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
@@ -260,6 +260,7 @@ static char *panwrap_format_name(enum mali_format format)
 	DEFINE_CASE(RGB10_A2_SNORM);
 	DEFINE_CASE(RGB10_A2UI);
 	DEFINE_CASE(RGB10_A2I);
+	DEFINE_CASE(Z32_UNORM);
 	DEFINE_CASE(R32_FIXED);
 	DEFINE_CASE(RG32_FIXED);
 	DEFINE_CASE(RGB32_FIXED);
-- 
2.18.1


From 387b36d9b3713240a3214b9bb084147e65cf0d27 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 05:05:02 +0000
Subject: [PATCH 13/16] Handle some special cases

---
 src/gallium/drivers/panfrost/pan_format.c | 24 ++++++++++++++---------
 1 file changed, 15 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index 91de94e11b..fcb4238d6c 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -94,6 +94,7 @@ panfrost_translate_channel_width(unsigned size)
                 case 32:
                         return MALI_CHANNEL_32;
                 default:
+                        fprintf(stderr, "Unknown width %d\n", size);
                         assert(0);
                         return 0;
         }
@@ -132,19 +133,24 @@ panfrost_translate_channel_type(unsigned type, unsigned size, bool norm) {
 enum mali_format
 panfrost_find_format(const struct util_format_description *desc)
 {
+        fprintf(stderr, "Searching for format %s\n", desc->name);
         struct util_format_channel_description chan = desc->channel[0];
 
-        /* First check for depth/stencil, which is special-cased at the
-         * moment */
+        /* Check for special formats */
+        switch (desc->format) {
+                case PIPE_FORMAT_R10G10B10A2_UNORM:
+                case PIPE_FORMAT_R10G10B10X2_UNORM:
+                case PIPE_FORMAT_B10G10R10A2_UNORM:
+                case PIPE_FORMAT_B10G10R10X2_UNORM:
+                        return MALI_RGB10_A2_UNORM;
 
-        if (desc->colorspace == UTIL_FORMAT_COLORSPACE_ZS) {
-                /* Make sure we know how to deal with it */
-                assert(chan.type == UTIL_FORMAT_TYPE_UNSIGNED);
-                assert(chan.size == 32);
-                assert(desc->nr_channels == 1);
-                assert(desc->swizzle[0] == 0 /* Z */);
+                /* TODO: ZS isn't really special case */
+                case PIPE_FORMAT_Z32_UNORM:
+                        return MALI_Z32_UNORM;
 
-                return MALI_Z32_UNORM;
+                default:
+                        /* Fallthrough to default */
+                        break;
         }
 
         /* Formats must match in channel count */
-- 
2.18.1


From 2e28e0900d7261023a115bcc706264b277266200 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 05:47:29 +0000
Subject: [PATCH 14/16] Solve issues with egl clients

---
 src/gallium/drivers/panfrost/meson.build      |  1 +
 src/gallium/drivers/panfrost/pan_format.c     | 15 ++-
 .../drivers/panfrost/panwrap/meson.build      |  1 +
 .../panfrost/panwrap/panwrap-decoder.c        | 92 +------------------
 .../panfrost/panwrap/panwrap-decoder.h        |  1 +
 5 files changed, 18 insertions(+), 92 deletions(-)

diff --git a/src/gallium/drivers/panfrost/meson.build b/src/gallium/drivers/panfrost/meson.build
index 28a137ec0b..ae1fc04463 100644
--- a/src/gallium/drivers/panfrost/meson.build
+++ b/src/gallium/drivers/panfrost/meson.build
@@ -41,6 +41,7 @@ files_panfrost = files(
   'pan_blending.c',
   'pan_blend_shaders.c',
   'pan_wallpaper.c',
+  'pan_pretty_print.c'
 )
 
 inc_panfrost = [
diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index fcb4238d6c..8273b9f74d 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -24,6 +24,9 @@
 
 #include "pan_format.h"
 
+/* From panwrap/panwrap-decoder, but we don't want to bring in all those headers */
+char *panwrap_format_name(enum mali_format format);
+
 /* Construct a default swizzle based on the number of components */
 
 static unsigned
@@ -138,11 +141,17 @@ panfrost_find_format(const struct util_format_description *desc)
 
         /* Check for special formats */
         switch (desc->format) {
+                /* XXX: This code is so obviously wrong, but it mimicks the
+                 * same old wrong behaviour and is necessarily for egl clients
+                 * for now?! */
+
                 case PIPE_FORMAT_R10G10B10A2_UNORM:
-                case PIPE_FORMAT_R10G10B10X2_UNORM:
                 case PIPE_FORMAT_B10G10R10A2_UNORM:
+                        return MALI_RGBA8_UNORM;
+                case PIPE_FORMAT_R10G10B10X2_UNORM:
                 case PIPE_FORMAT_B10G10R10X2_UNORM:
-                        return MALI_RGB10_A2_UNORM;
+                        return MALI_RGBA8_UNORM;
+                        //return MALI_RGB10_A2_UNORM;
 
                 /* TODO: ZS isn't really special case */
                 case PIPE_FORMAT_Z32_UNORM:
@@ -177,6 +186,8 @@ panfrost_find_format(const struct util_format_description *desc)
                         break;
         }
 
+        fprintf(stderr, "...%s\n", panwrap_format_name((enum mali_format) format));
+
         return (enum mali_format) format;
 }
 
diff --git a/src/gallium/drivers/panfrost/panwrap/meson.build b/src/gallium/drivers/panfrost/panwrap/meson.build
index 54d2441925..395eca3026 100644
--- a/src/gallium/drivers/panfrost/panwrap/meson.build
+++ b/src/gallium/drivers/panfrost/panwrap/meson.build
@@ -3,6 +3,7 @@ srcs = [
     'panwrap-util.c',
     'panwrap-mmap.c',
     'panwrap-decoder.c',
+    '../pan_pretty_print.c'
 ]
 
 shared_library(
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
index a9dc0840c7..e47630cfb4 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
@@ -27,6 +27,8 @@
 #include <memory.h>
 #include "panwrap.h"
 
+#include "../pan_pretty_print.h"
+
 #define MEMORY_PROP(obj, p) {\
 	char *a = pointer_as_memory_reference(obj->p); \
 	panwrap_prop("%s = %s", #p, a); \
@@ -250,96 +252,6 @@ panwrap_channel_name(enum mali_channel channel)
 }
 #undef DEFINE_CASE
 
-#define DEFINE_CASE(name) case MALI_## name: return "MALI_" #name
-static char *panwrap_format_name(enum mali_format format)
-{
-	static char unk_format_str[5];
-
-	switch (format) {
-	DEFINE_CASE(RGB10_A2_UNORM);
-	DEFINE_CASE(RGB10_A2_SNORM);
-	DEFINE_CASE(RGB10_A2UI);
-	DEFINE_CASE(RGB10_A2I);
-	DEFINE_CASE(Z32_UNORM);
-	DEFINE_CASE(R32_FIXED);
-	DEFINE_CASE(RG32_FIXED);
-	DEFINE_CASE(RGB32_FIXED);
-	DEFINE_CASE(RGBA32_FIXED);
-	DEFINE_CASE(R11F_G11F_B10F);
-	DEFINE_CASE(VARYING_POS);
-	DEFINE_CASE(VARYING_DISCARD);
-
-	DEFINE_CASE(R8_SNORM);
-	DEFINE_CASE(R16_SNORM);
-	DEFINE_CASE(R32_SNORM);
-	DEFINE_CASE(RG8_SNORM);
-	DEFINE_CASE(RG16_SNORM);
-	DEFINE_CASE(RG32_SNORM);
-	DEFINE_CASE(RGB8_SNORM);
-	DEFINE_CASE(RGB16_SNORM);
-	DEFINE_CASE(RGB32_SNORM);
-	DEFINE_CASE(RGBA8_SNORM);
-	DEFINE_CASE(RGBA16_SNORM);
-	DEFINE_CASE(RGBA32_SNORM);
-
-	DEFINE_CASE(R8UI);
-	DEFINE_CASE(R16UI);
-	DEFINE_CASE(R32UI);
-	DEFINE_CASE(RG8UI);
-	DEFINE_CASE(RG16UI);
-	DEFINE_CASE(RG32UI);
-	DEFINE_CASE(RGB8UI);
-	DEFINE_CASE(RGB16UI);
-	DEFINE_CASE(RGB32UI);
-	DEFINE_CASE(RGBA8UI);
-	DEFINE_CASE(RGBA16UI);
-	DEFINE_CASE(RGBA32UI);
-
-	DEFINE_CASE(R8_UNORM);
-	DEFINE_CASE(R16_UNORM);
-	DEFINE_CASE(R32_UNORM);
-	DEFINE_CASE(R32F);
-	DEFINE_CASE(RG8_UNORM);
-	DEFINE_CASE(RG16_UNORM);
-	DEFINE_CASE(RG32_UNORM);
-	DEFINE_CASE(RG32F);
-	DEFINE_CASE(RGB8_UNORM);
-	DEFINE_CASE(RGB16_UNORM);
-	DEFINE_CASE(RGB32_UNORM);
-	DEFINE_CASE(RGB32F);
-	DEFINE_CASE(RGBA8_UNORM);
-	DEFINE_CASE(RGBA16_UNORM);
-	DEFINE_CASE(RGBA32_UNORM);
-	DEFINE_CASE(RGBA32F);
-
-	DEFINE_CASE(R8I);
-	DEFINE_CASE(R16I);
-	DEFINE_CASE(R32I);
-	DEFINE_CASE(RG8I);
-	DEFINE_CASE(R16F);
-	DEFINE_CASE(RG16I);
-	DEFINE_CASE(RG32I);
-	DEFINE_CASE(RG16F);
-	DEFINE_CASE(RGB8I);
-	DEFINE_CASE(RGB16I);
-	DEFINE_CASE(RGB32I);
-	DEFINE_CASE(RGB16F);
-	DEFINE_CASE(RGBA8I);
-	DEFINE_CASE(RGBA16I);
-	DEFINE_CASE(RGBA32I);
-	DEFINE_CASE(RGBA16F);
-
-	DEFINE_CASE(RGBA4);
-	DEFINE_CASE(RGBA8_2);
-	DEFINE_CASE(RGB10_A2_2);
-	default:
-	snprintf(unk_format_str, sizeof(unk_format_str), "0x%02x", format);
-	return unk_format_str;
-	}
-}
-
-#undef DEFINE_CASE
-
 #define DEFINE_CASE(name) case MALI_WRAP_## name: return "MALI_WRAP_" #name
 static char *
 panwrap_wrap_mode_name(enum mali_wrap_mode op)
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h
index 7a2c7a5d43..2c035285c5 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.h
@@ -31,5 +31,6 @@
 
 int panwrap_replay_jc(mali_ptr jc_gpu_va, bool bifrost);
 int panwrap_replay_soft_replay(mali_ptr jc_gpu_va);
+char *panwrap_format_name(enum mali_format format);
 
 #endif /* !PANWRAP_DECODER_H */
-- 
2.18.1


From 0473b467c73dedd012a8f37b95dfbd68403ea41b Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 06:31:13 +0000
Subject: [PATCH 15/16] Let Xwayland do somewhat of the right thing, for the
 moment

---
 src/gallium/drivers/panfrost/pan_context.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 453391d5e6..3bbf4e02ed 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1672,7 +1672,8 @@ panfrost_draw_vbo(
         /* Fallback for non-ES draw modes */
 
         if (info->mode >= PIPE_PRIM_QUADS) {
-                mode = PIPE_PRIM_TRIANGLE_STRIP;
+                printf("XXX: Missing non-ES draw mode\n");
+                mode = PIPE_PRIM_TRIANGLE_FAN;
                 /*
                 util_primconvert_save_rasterizer_state(ctx->primconvert, &ctx->rasterizer->base);
                 util_primconvert_draw_vbo(ctx->primconvert, info);
-- 
2.18.1


From 9ecb89df0ab18ccf4dee723e1a7d7ddd71609713 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 7 Jan 2019 06:51:12 +0000
Subject: [PATCH 16/16] Checkin messing files

---
 .../drivers/panfrost/pan_pretty_print.c       | 116 ++++++++++++++++++
 .../drivers/panfrost/pan_pretty_print.h       |  30 +++++
 2 files changed, 146 insertions(+)
 create mode 100644 src/gallium/drivers/panfrost/pan_pretty_print.c
 create mode 100644 src/gallium/drivers/panfrost/pan_pretty_print.h

diff --git a/src/gallium/drivers/panfrost/pan_pretty_print.c b/src/gallium/drivers/panfrost/pan_pretty_print.c
new file mode 100644
index 0000000000..0256b84675
--- /dev/null
+++ b/src/gallium/drivers/panfrost/pan_pretty_print.c
@@ -0,0 +1,116 @@
+/*
+ * © Copyright 2017-2098 The Panfrost Communiy
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "pan_pretty_print.h"
+
+#include <stdio.h>
+
+#define DEFINE_CASE(name) case MALI_## name: return "MALI_" #name
+char *panwrap_format_name(enum mali_format format)
+{
+	static char unk_format_str[5];
+
+	switch (format) {
+	DEFINE_CASE(RGB10_A2_UNORM);
+	DEFINE_CASE(RGB10_A2_SNORM);
+	DEFINE_CASE(RGB10_A2UI);
+	DEFINE_CASE(RGB10_A2I);
+	DEFINE_CASE(Z32_UNORM);
+	DEFINE_CASE(R32_FIXED);
+	DEFINE_CASE(RG32_FIXED);
+	DEFINE_CASE(RGB32_FIXED);
+	DEFINE_CASE(RGBA32_FIXED);
+	DEFINE_CASE(R11F_G11F_B10F);
+	DEFINE_CASE(VARYING_POS);
+	DEFINE_CASE(VARYING_DISCARD);
+
+	DEFINE_CASE(R8_SNORM);
+	DEFINE_CASE(R16_SNORM);
+	DEFINE_CASE(R32_SNORM);
+	DEFINE_CASE(RG8_SNORM);
+	DEFINE_CASE(RG16_SNORM);
+	DEFINE_CASE(RG32_SNORM);
+	DEFINE_CASE(RGB8_SNORM);
+	DEFINE_CASE(RGB16_SNORM);
+	DEFINE_CASE(RGB32_SNORM);
+	DEFINE_CASE(RGBA8_SNORM);
+	DEFINE_CASE(RGBA16_SNORM);
+	DEFINE_CASE(RGBA32_SNORM);
+
+	DEFINE_CASE(R8UI);
+	DEFINE_CASE(R16UI);
+	DEFINE_CASE(R32UI);
+	DEFINE_CASE(RG8UI);
+	DEFINE_CASE(RG16UI);
+	DEFINE_CASE(RG32UI);
+	DEFINE_CASE(RGB8UI);
+	DEFINE_CASE(RGB16UI);
+	DEFINE_CASE(RGB32UI);
+	DEFINE_CASE(RGBA8UI);
+	DEFINE_CASE(RGBA16UI);
+	DEFINE_CASE(RGBA32UI);
+
+	DEFINE_CASE(R8_UNORM);
+	DEFINE_CASE(R16_UNORM);
+	DEFINE_CASE(R32_UNORM);
+	DEFINE_CASE(R32F);
+	DEFINE_CASE(RG8_UNORM);
+	DEFINE_CASE(RG16_UNORM);
+	DEFINE_CASE(RG32_UNORM);
+	DEFINE_CASE(RG32F);
+	DEFINE_CASE(RGB8_UNORM);
+	DEFINE_CASE(RGB16_UNORM);
+	DEFINE_CASE(RGB32_UNORM);
+	DEFINE_CASE(RGB32F);
+	DEFINE_CASE(RGBA8_UNORM);
+	DEFINE_CASE(RGBA16_UNORM);
+	DEFINE_CASE(RGBA32_UNORM);
+	DEFINE_CASE(RGBA32F);
+
+	DEFINE_CASE(R8I);
+	DEFINE_CASE(R16I);
+	DEFINE_CASE(R32I);
+	DEFINE_CASE(RG8I);
+	DEFINE_CASE(R16F);
+	DEFINE_CASE(RG16I);
+	DEFINE_CASE(RG32I);
+	DEFINE_CASE(RG16F);
+	DEFINE_CASE(RGB8I);
+	DEFINE_CASE(RGB16I);
+	DEFINE_CASE(RGB32I);
+	DEFINE_CASE(RGB16F);
+	DEFINE_CASE(RGBA8I);
+	DEFINE_CASE(RGBA16I);
+	DEFINE_CASE(RGBA32I);
+	DEFINE_CASE(RGBA16F);
+
+	DEFINE_CASE(RGBA4);
+	DEFINE_CASE(RGBA8_2);
+	DEFINE_CASE(RGB10_A2_2);
+	default:
+	snprintf(unk_format_str, sizeof(unk_format_str), "0x%02x", format);
+	return unk_format_str;
+	}
+}
+
+#undef DEFINE_CASE
diff --git a/src/gallium/drivers/panfrost/pan_pretty_print.h b/src/gallium/drivers/panfrost/pan_pretty_print.h
new file mode 100644
index 0000000000..084be80286
--- /dev/null
+++ b/src/gallium/drivers/panfrost/pan_pretty_print.h
@@ -0,0 +1,30 @@
+/*
+ * © Copyright 2017-2098 The Panfrost Communiy
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __PAN_PRETTY_H
+#define __PAN_PRETTY_H
+
+#include "panfrost-job.h"
+char *panwrap_format_name(enum mali_format format);
+
+#endif
-- 
2.18.1

