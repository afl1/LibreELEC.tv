From 9f974958577400abdd42abf98484d230414f69d0 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Sat, 11 Aug 2018 04:07:48 +0200
Subject: [PATCH 05/11] vdec: Rework the recycle mechanism

Now the thread code appears only once in vdec.c.
Added can_recycle and recycle codec ops.

Also remove "meson" from the dts compatibles.

I've decided to no longer force push into my dev branch
to better track the changes I make.
Patchset will be redone cleanly for 4.19.
---
 arch/arm64/boot/dts/amlogic/meson-gx.dtsi        |  2 +-
 arch/arm64/boot/dts/amlogic/meson-gxbb.dtsi      |  2 +-
 arch/arm64/boot/dts/amlogic/meson-gxl.dtsi       |  2 +-
 arch/arm64/boot/dts/amlogic/meson-gxm.dtsi       |  2 +-
 drivers/media/platform/meson/vdec/codec_h264.c   | 58 +++++---------------
 drivers/media/platform/meson/vdec/codec_mjpeg.c  | 57 +++----------------
 drivers/media/platform/meson/vdec/codec_mpeg12.c | 39 +++----------
 drivers/media/platform/meson/vdec/codec_mpeg4.c  | 41 +++-----------
 drivers/media/platform/meson/vdec/esparser.c     | 11 +---
 drivers/media/platform/meson/vdec/vdec.c         | 70 +++++++++++++++++++-----
 drivers/media/platform/meson/vdec/vdec.h         |  4 ++
 11 files changed, 104 insertions(+), 184 deletions(-)

diff --git a/arch/arm64/boot/dts/amlogic/meson-gx.dtsi b/arch/arm64/boot/dts/amlogic/meson-gx.dtsi
index 2480527..25623cd 100644
--- a/arch/arm64/boot/dts/amlogic/meson-gx.dtsi
+++ b/arch/arm64/boot/dts/amlogic/meson-gx.dtsi
@@ -484,7 +484,7 @@
 		};
 
 		vdec: video-decoder@0xd0050000 {
-			compatible = "amlogic,meson-gx-vdec";
+			compatible = "amlogic,gx-vdec";
 			reg = <0x0 0xc8820000 0x0 0x10000
 			       0x0 0xc110a580 0x0 0xe4
 			       0x0 0xc8838000 0x0 0x60>;
diff --git a/arch/arm64/boot/dts/amlogic/meson-gxbb.dtsi b/arch/arm64/boot/dts/amlogic/meson-gxbb.dtsi
index 0ea4b56..31c1572 100644
--- a/arch/arm64/boot/dts/amlogic/meson-gxbb.dtsi
+++ b/arch/arm64/boot/dts/amlogic/meson-gxbb.dtsi
@@ -776,7 +776,7 @@
 };
 
 &vdec {
-	compatible = "amlogic,meson-gxbb-vdec";
+	compatible = "amlogic,gxbb-vdec";
 	clocks = <&clkc CLKID_DOS_PARSER>, <&clkc CLKID_DOS>, <&clkc CLKID_VDEC_1>, <&clkc CLKID_VDEC_HEVC>;
 	clock-names = "dos_parser", "dos", "vdec_1", "vdec_hevc";
 	resets = <&reset RESET_PARSER>;
diff --git a/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi b/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
index 20045a9..9931e76 100644
--- a/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
+++ b/arch/arm64/boot/dts/amlogic/meson-gxl.dtsi
@@ -777,7 +777,7 @@
 };
 
 &vdec {
-	compatible = "amlogic,meson-gxl-vdec";
+	compatible = "amlogic,gxl-vdec";
 	clocks = <&clkc CLKID_DOS_PARSER>, <&clkc CLKID_DOS>, <&clkc CLKID_VDEC_1>, <&clkc CLKID_VDEC_HEVC>;
 	clock-names = "dos_parser", "dos", "vdec_1", "vdec_hevc";
 	resets = <&reset RESET_PARSER>;
diff --git a/arch/arm64/boot/dts/amlogic/meson-gxm.dtsi b/arch/arm64/boot/dts/amlogic/meson-gxm.dtsi
index 4ce7b12..2f35649 100644
--- a/arch/arm64/boot/dts/amlogic/meson-gxm.dtsi
+++ b/arch/arm64/boot/dts/amlogic/meson-gxm.dtsi
@@ -119,5 +119,5 @@
 };
 
 &vdec {
-	compatible = "amlogic,meson-gxm-vdec";
+	compatible = "amlogic,gxm-vdec";
 };
diff --git a/drivers/media/platform/meson/vdec/codec_h264.c b/drivers/media/platform/meson/vdec/codec_h264.c
index ab473d3..4e3db70 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.c
+++ b/drivers/media/platform/meson/vdec/codec_h264.c
@@ -72,51 +72,23 @@ struct codec_h264 {
 	/* Buffer for parsed SEI data ; > M8 ? */
 	void      *sei_vaddr;
 	dma_addr_t sei_paddr;
-
-	/* Housekeeping thread for recycling buffers into the hardware */
-	struct task_struct *buffers_thread;
 };
 
-static void codec_h264_recycle_first(struct vdec_session *sess)
+static int codec_h264_can_recycle(struct vdec_core *core)
 {
-	struct vdec_core *core = sess->core;
-	struct vdec_buffer *tmp;
-
-	tmp = list_first_entry(&sess->bufs_recycle, struct vdec_buffer, list);
+	return !readl_relaxed(core->dos_base + AV_SCRATCH_7) ||
+	       !readl_relaxed(core->dos_base + AV_SCRATCH_8);
+}
 
+static void codec_h264_recycle(struct vdec_core *core, u32 buf_idx)
+{
 	/* Tell the decoder he can recycle this buffer.
 	 * AV_SCRATCH_8 serves the same purpose.
 	 */
 	if (!readl_relaxed(core->dos_base + AV_SCRATCH_7))
-		writel_relaxed(tmp->index + 1, core->dos_base + AV_SCRATCH_7);
+		writel_relaxed(buf_idx + 1, core->dos_base + AV_SCRATCH_7);
 	else
-		writel_relaxed(tmp->index + 1, core->dos_base + AV_SCRATCH_8);
-
-	dev_dbg(core->dev, "Buffer %d recycled\n", tmp->index);
-
-	list_del(&tmp->list);
-	kfree(tmp);
-}
-
-static int codec_h264_buffers_thread(void *data)
-{
-	struct vdec_session *sess = data;
-	struct vdec_core *core = sess->core;
-
-	while (!kthread_should_stop()) {
-		mutex_lock(&sess->bufs_recycle_lock);
-		while (!list_empty(&sess->bufs_recycle) &&
-		       (!readl_relaxed(core->dos_base + AV_SCRATCH_7) ||
-		        !readl_relaxed(core->dos_base + AV_SCRATCH_8)))
-		{
-			codec_h264_recycle_first(sess);
-		}
-		mutex_unlock(&sess->bufs_recycle_lock);
-
-		usleep_range(5000, 10000);
-	}
-
-	return 0;
+		writel_relaxed(buf_idx + 1, core->dos_base + AV_SCRATCH_8);
 }
 
 static int codec_h264_start(struct vdec_session *sess) {
@@ -183,9 +155,6 @@ static int codec_h264_start(struct vdec_session *sess) {
 	writel_relaxed(0, core->dos_base + DOS_SW_RESET0);
 
 	readl_relaxed(core->dos_base + DOS_SW_RESET0);
-	
-	h264->buffers_thread = kthread_run(codec_h264_buffers_thread, sess, "buffers_done");
-	
 	return 0;
 }
 
@@ -194,8 +163,6 @@ static int codec_h264_stop(struct vdec_session *sess)
 	struct codec_h264 *h264 = sess->priv;
 	struct vdec_core *core = sess->core;
 
-	kthread_stop(h264->buffers_thread);
-
 	if (h264->ext_fw_vaddr)
 		dma_free_coherent(core->dev, SIZE_EXT_FW, h264->ext_fw_vaddr, h264->ext_fw_paddr);
 	
@@ -352,7 +319,7 @@ static irqreturn_t codec_h264_threaded_isr(struct vdec_session *sess)
 	switch (cmd) {
 	case 1:
 		codec_h264_set_param(sess);
-		goto end;
+		break;
 	case 2:
 		codec_h264_frames_ready(sess, status);
 		break;
@@ -374,9 +341,9 @@ static irqreturn_t codec_h264_threaded_isr(struct vdec_session *sess)
 		break;
 	}
 
-	writel_relaxed(0, core->dos_base + AV_SCRATCH_0);
+	if (cmd > 1)
+		writel_relaxed(0, core->dos_base + AV_SCRATCH_0);
 
-end:
 	/* Decoder has some SEI data for us ; ignore */
 	if (readl_relaxed(core->dos_base + AV_SCRATCH_J) & SEI_DATA_READY)
 		writel_relaxed(0, core->dos_base + AV_SCRATCH_J);
@@ -402,6 +369,7 @@ struct vdec_codec_ops codec_h264_ops = {
 	.load_extended_firmware = codec_h264_load_extended_firmware,
 	.isr = codec_h264_isr,
 	.threaded_isr = codec_h264_threaded_isr,
-	.notify_dst_buffer = vdec_queue_recycle,
+	.can_recycle = codec_h264_can_recycle,
+	.recycle = codec_h264_recycle,
 };
 
diff --git a/drivers/media/platform/meson/vdec/codec_mjpeg.c b/drivers/media/platform/meson/vdec/codec_mjpeg.c
index 57b56d7..7553de0 100644
--- a/drivers/media/platform/meson/vdec/codec_mjpeg.c
+++ b/drivers/media/platform/meson/vdec/codec_mjpeg.c
@@ -33,40 +33,14 @@
 
 #define DOS_SW_RESET0		0xfc00
 
-struct codec_mjpeg {
-	/* Housekeeping thread for marking buffers to DONE
-	 * and recycling them into the hardware
-	 */
-	struct task_struct *buffers_thread;
-};
-
-static int codec_mjpeg_buffers_thread(void *data)
+static int codec_mjpeg_can_recycle(struct vdec_core *core)
 {
-	struct vdec_buffer *tmp;
-	struct vdec_session *sess = data;
-	struct vdec_core *core = sess->core;;
-
-	while (!kthread_should_stop()) {
-		mutex_lock(&sess->bufs_recycle_lock);
-		while (!list_empty(&sess->bufs_recycle) &&
-		       !readl_relaxed(core->dos_base + MREG_TO_AMRISC))
-		{
-			tmp = list_first_entry(&sess->bufs_recycle, struct vdec_buffer, list);
-
-			/* Tell the decoder he can recycle this buffer */
-			writel_relaxed(tmp->index + 1, core->dos_base + MREG_TO_AMRISC);
-
-			dev_dbg(core->dev, "Buffer %d recycled\n", tmp->index);
-
-			list_del(&tmp->list);
-			kfree(tmp);
-		}
-		mutex_unlock(&sess->bufs_recycle_lock);
-
-		usleep_range(5000, 10000);
-	}
+	return !readl_relaxed(core->dos_base + MREG_TO_AMRISC);
+}
 
-	return 0;
+static void codec_mjpeg_recycle(struct vdec_core *core, u32 buf_idx)
+{
+	writel_relaxed(buf_idx + 1, core->dos_base + MREG_TO_AMRISC);
 }
 
 /* 4 point triangle */
@@ -131,13 +105,6 @@ static void codec_mjpeg_init_scaler(struct vdec_core *core)
 static int codec_mjpeg_start(struct vdec_session *sess)
 {
 	struct vdec_core *core = sess->core;
-	struct codec_mjpeg *mjpeg = sess->priv;
-
-	mjpeg = kzalloc(sizeof(*mjpeg), GFP_KERNEL);
-	if (!mjpeg)
-		return -ENOMEM;
-
-	sess->priv = mjpeg;
 
 	writel_relaxed((1 << 7) | (1 << 6), core->dos_base + DOS_SW_RESET0);
 	writel_relaxed(0, core->dos_base + DOS_SW_RESET0);
@@ -159,20 +126,11 @@ static int codec_mjpeg_start(struct vdec_session *sess)
 	/* Enable 2-plane output */
 	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
 
-	mjpeg->buffers_thread = kthread_run(codec_mjpeg_buffers_thread, sess, "buffers_done");
-
 	return 0;
 }
 
 static int codec_mjpeg_stop(struct vdec_session *sess)
 {
-	struct codec_mjpeg *mjpeg = sess->priv;
-
-	kthread_stop(mjpeg->buffers_thread);
-
-	kfree(mjpeg);
-	sess->priv = 0;
-
 	return 0;
 }
 
@@ -199,5 +157,6 @@ struct vdec_codec_ops codec_mjpeg_ops = {
 	.start = codec_mjpeg_start,
 	.stop = codec_mjpeg_stop,
 	.isr = codec_mjpeg_isr,
-	.notify_dst_buffer = vdec_queue_recycle,
+	.can_recycle = codec_mjpeg_can_recycle,
+	.recycle = codec_mjpeg_recycle,
 };
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg12.c b/drivers/media/platform/meson/vdec/codec_mpeg12.c
index 8682adc..a85046d 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg12.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg12.c
@@ -45,36 +45,16 @@ struct codec_mpeg12 {
 	/* Buffer for the MPEG1/2 Workspace */
 	void      *workspace_vaddr;
 	dma_addr_t workspace_paddr;
-
-	/* Housekeeping thread for recycling buffers into the hardware */
-	struct task_struct *buffers_thread;
 };
 
-static int codec_mpeg12_buffers_thread(void *data)
+static int codec_mpeg12_can_recycle(struct vdec_core *core)
 {
-	struct vdec_buffer *tmp;
-	struct vdec_session *sess = data;
-	struct vdec_core *core = sess->core;;
-
-	while (!kthread_should_stop()) {
-		mutex_lock(&sess->bufs_recycle_lock);
-		while (!list_empty(&sess->bufs_recycle) &&
-		       !readl_relaxed(core->dos_base + MREG_BUFFERIN))
-		{
-			tmp = list_first_entry(&sess->bufs_recycle, struct vdec_buffer, list);
-
-			/* Tell the decoder he can recycle this buffer */
-			writel_relaxed(tmp->index + 1, core->dos_base + MREG_BUFFERIN);
-
-			list_del(&tmp->list);
-			kfree(tmp);
-		}
-		mutex_unlock(&sess->bufs_recycle_lock);
-
-		usleep_range(5000, 10000);
-	}
+	return !readl_relaxed(core->dos_base + MREG_BUFFERIN);
+}
 
-	return 0;
+static void codec_mpeg12_recycle(struct vdec_core *core, u32 buf_idx)
+{
+	writel_relaxed(buf_idx + 1, core->dos_base + MREG_BUFFERIN);
 }
 
 static int codec_mpeg12_start(struct vdec_session *sess) {
@@ -120,8 +100,6 @@ static int codec_mpeg12_start(struct vdec_session *sess) {
 	/* Enable NV21 */
 	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
 
-	mpeg12->buffers_thread = kthread_run(codec_mpeg12_buffers_thread, sess, "buffers_done");
-
 	return 0;
 
 free_mpeg12:
@@ -134,8 +112,6 @@ static int codec_mpeg12_stop(struct vdec_session *sess)
 	struct codec_mpeg12 *mpeg12 = sess->priv;
 	struct vdec_core *core = sess->core;
 
-	kthread_stop(mpeg12->buffers_thread);
-
 	if (mpeg12->workspace_vaddr) {
 		dma_free_coherent(core->dev, SIZE_WORKSPACE, mpeg12->workspace_vaddr, mpeg12->workspace_paddr);
 		mpeg12->workspace_vaddr = 0;
@@ -178,6 +154,7 @@ struct vdec_codec_ops codec_mpeg12_ops = {
 	.start = codec_mpeg12_start,
 	.stop = codec_mpeg12_stop,
 	.isr = codec_mpeg12_isr,
-	.notify_dst_buffer = vdec_queue_recycle,
+	.can_recycle = codec_mpeg12_can_recycle,
+	.recycle = codec_mpeg12_recycle,
 };
 
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg4.c b/drivers/media/platform/meson/vdec/codec_mpeg4.c
index 458be02a..911d303 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg4.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg4.c
@@ -41,39 +41,19 @@
 #define DOS_SW_RESET0 0xfc00
 
 struct codec_mpeg4 {
-	/* Buffer for the MPEG1/2 Workspace */
+	/* Buffer for the MPEG4 Workspace */
 	void      *workspace_vaddr;
 	dma_addr_t workspace_paddr;
-
-	/* Housekeeping thread for recycling buffers into the hardware */
-	struct task_struct *buffers_thread;
 };
 
-static int codec_mpeg4_buffers_thread(void *data)
+static int codec_mpeg4_can_recycle(struct vdec_core *core)
 {
-	struct vdec_buffer *tmp;
-	struct vdec_session *sess = data;
-	struct vdec_core *core = sess->core;;
-
-	while (!kthread_should_stop()) {
-		mutex_lock(&sess->bufs_recycle_lock);
-		while (!list_empty(&sess->bufs_recycle) &&
-		       !readl_relaxed(core->dos_base + MREG_BUFFERIN))
-		{
-			tmp = list_first_entry(&sess->bufs_recycle, struct vdec_buffer, list);
-
-			/* Tell the decoder he can recycle this buffer */
-			writel_relaxed(~(1 << tmp->index), core->dos_base + MREG_BUFFERIN);
-
-			list_del(&tmp->list);
-			kfree(tmp);
-		}
-		mutex_unlock(&sess->bufs_recycle_lock);
-
-		usleep_range(5000, 10000);
-	}
+	return !readl_relaxed(core->dos_base + MREG_BUFFERIN);
+}
 
-	return 0;
+static void codec_mpeg4_recycle(struct vdec_core *core, u32 buf_idx)
+{
+	writel_relaxed(~(1 << buf_idx), core->dos_base + MREG_BUFFERIN);
 }
 
 /* The MPEG4 canvas regs are not contiguous,
@@ -153,8 +133,6 @@ static int codec_mpeg4_start(struct vdec_session *sess) {
 	/* Enable NV21 */
 	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
 
-	mpeg4->buffers_thread = kthread_run(codec_mpeg4_buffers_thread, sess, "buffers_done");
-
 	return 0;
 
 free_mpeg4:
@@ -167,8 +145,6 @@ static int codec_mpeg4_stop(struct vdec_session *sess)
 	struct codec_mpeg4 *mpeg4 = sess->priv;
 	struct vdec_core *core = sess->core;
 
-	kthread_stop(mpeg4->buffers_thread);
-
 	if (mpeg4->workspace_vaddr) {
 		dma_free_coherent(core->dev, SIZE_WORKSPACE, mpeg4->workspace_vaddr, mpeg4->workspace_paddr);
 		mpeg4->workspace_vaddr = 0;
@@ -208,6 +184,7 @@ struct vdec_codec_ops codec_mpeg4_ops = {
 	.start = codec_mpeg4_start,
 	.stop = codec_mpeg4_stop,
 	.isr = codec_mpeg4_isr,
-	.notify_dst_buffer = vdec_queue_recycle,
+	.can_recycle = codec_mpeg4_can_recycle,
+	.recycle = codec_mpeg4_recycle,
 };
 
diff --git a/drivers/media/platform/meson/vdec/esparser.c b/drivers/media/platform/meson/vdec/esparser.c
index 9e2df80..f9d8560 100644
--- a/drivers/media/platform/meson/vdec/esparser.c
+++ b/drivers/media/platform/meson/vdec/esparser.c
@@ -217,12 +217,8 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 	num_dst_bufs += v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
 
 	if (esparser_vififo_get_free_space(sess) < payload_size ||
-	    atomic_read(&sess->esparser_queued_bufs) >= num_dst_bufs) {
-		dev_dbg(core->dev, "esparser: queue full. %u/%u\n",
-			atomic_read(&sess->esparser_queued_bufs),
-			num_dst_bufs);
+	    atomic_read(&sess->esparser_queued_bufs) >= num_dst_bufs)
 		return -EAGAIN;
-	}
 
 	v4l2_m2m_src_buf_remove_by_buf(sess->m2m_ctx, vbuf);
 	vdec_add_ts_reorder(sess, vb->timestamp);
@@ -233,7 +229,7 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 	 * or buffer decoding errors, as it looks like the ESPARSER
 	 * gets confused with too much data thrown in too quickly.
 	 */
-	usleep_range(5000, 5000);
+	usleep_range(5000, 10000);
 
 	pad_size = esparser_pad_start_code(vb);
 	ret = esparser_write_data(core, phy, payload_size + pad_size);
@@ -243,7 +239,7 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 		vbuf->field = V4L2_FIELD_NONE;
 		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
 	} else if (ret <= 0) {
-		printk("ESPARSER input parsing error\n");
+		dev_warn(core->dev, "esparser: input parsing error\n");
 		vdec_remove_ts(sess, vb->timestamp);
 		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
 		writel_relaxed(0, core->esparser_base + PARSER_FETCH_CMD);
@@ -315,7 +311,6 @@ int esparser_init(struct platform_device *pdev, struct vdec_core *core)
 	int ret;
 	int irq;
 
-	/* TODO: name the IRQs */
 	irq = platform_get_irq(pdev, 1);
 	if (irq < 0) {
 		dev_err(dev, "Failed getting ESPARSER IRQ from dtb\n");
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 7357f34..f306568 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -45,6 +45,39 @@ u32 vdec_get_output_size(struct vdec_session *sess)
 	return get_output_size(sess->width, sess->height);
 }
 
+static int vdec_codec_needs_recycle(struct vdec_session *sess)
+{
+	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	return codec_ops->can_recycle && codec_ops->recycle;
+}
+
+static int vdec_recycle_thread(void *data)
+{
+	struct vdec_session *sess = data;
+	struct vdec_core *core = sess->core;
+	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
+	struct vdec_buffer *tmp;
+
+	while (!kthread_should_stop()) {
+		mutex_lock(&sess->bufs_recycle_lock);
+		while (!list_empty(&sess->bufs_recycle) &&
+		       codec_ops->can_recycle(core))
+		{
+			tmp = list_first_entry(&sess->bufs_recycle,
+					       struct vdec_buffer, list);
+			codec_ops->recycle(core, tmp->index);
+			dev_dbg(core->dev, "Buffer %d recycled\n", tmp->index);
+			list_del(&tmp->list);
+			kfree(tmp);
+		}
+		mutex_unlock(&sess->bufs_recycle_lock);
+
+		usleep_range(5000, 10000);
+	}
+
+	return 0;
+}
+
 static int vdec_poweron(struct vdec_session *sess)
 {
 	int ret;
@@ -143,17 +176,16 @@ static void vdec_vb2_buf_queue(struct vb2_buffer *vb)
 	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct vdec_session *sess = vb2_get_drv_priv(vb->vb2_queue);
 	struct v4l2_m2m_ctx *m2m_ctx = sess->m2m_ctx;
-	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
 
 	mutex_lock(&sess->lock);
 	v4l2_m2m_buf_queue(m2m_ctx, vbuf);
 
-	if (!(sess->streamon_out & sess->streamon_cap))
+	if (!sess->streamon_out || !sess->streamon_cap)
 		goto unlock;
-	
+
 	if (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE &&
-	    codec_ops->notify_dst_buffer)
-		codec_ops->notify_dst_buffer(sess, vb);
+	    vdec_codec_needs_recycle(sess))
+		vdec_queue_recycle(sess, vb);
 
 	schedule_work(&sess->esparser_queue_work);
 unlock:
@@ -173,15 +205,17 @@ static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 	else
 		sess->streamon_cap = 1;
 
-	if (!(sess->streamon_out & sess->streamon_cap)) {
+	if (!sess->streamon_out || !sess->streamon_cap) {
 		mutex_unlock(&sess->lock);
 		return 0;
 	}
 
 	sess->vififo_size = SIZE_VIFIFO;
-	sess->vififo_vaddr = dma_alloc_coherent(sess->core->dev, sess->vififo_size, &sess->vififo_paddr, GFP_KERNEL);
+	sess->vififo_vaddr =
+		dma_alloc_coherent(sess->core->dev, sess->vififo_size,
+				   &sess->vififo_paddr, GFP_KERNEL);
 	if (!sess->vififo_vaddr) {
-		printk("Failed to request VIFIFO buffer\n");
+		dev_err(sess->core->dev, "Failed to request VIFIFO buffer\n");
 		ret = -ENOMEM;
 		goto bufs_done;
 	}
@@ -192,17 +226,22 @@ static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 		goto vififo_free;
 
 	sess->sequence_cap = 0;
+	if (vdec_codec_needs_recycle(sess))
+		sess->recycle_thread = kthread_run(vdec_recycle_thread, sess,
+						   "vdec_recycle");
 	mutex_unlock(&sess->lock);
 
 	return 0;
 
 vififo_free:
-	dma_free_coherent(sess->core->dev, sess->vififo_size, sess->vififo_vaddr, sess->vififo_paddr);
+	dma_free_coherent(sess->core->dev, sess->vififo_size,
+			  sess->vififo_vaddr, sess->vififo_paddr);
 bufs_done:
 	while ((buf = v4l2_m2m_src_buf_remove(sess->m2m_ctx)))
 		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);
 	while ((buf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx)))
 		v4l2_m2m_buf_done(buf, VB2_BUF_STATE_QUEUED);
+
 	if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
 		sess->streamon_out = 0;
 	else
@@ -218,7 +257,9 @@ void vdec_stop_streaming(struct vb2_queue *q)
 
 	mutex_lock(&sess->lock);
 
-	if (sess->streamon_out & sess->streamon_cap) {
+	if (sess->streamon_out && sess->streamon_cap) {
+		if (vdec_codec_needs_recycle(sess))
+			kthread_stop(sess->recycle_thread);
 		vdec_poweroff(sess);
 		dma_free_coherent(sess->core->dev, sess->vififo_size, sess->vififo_vaddr, sess->vififo_paddr);
 		INIT_LIST_HEAD(&sess->bufs);
@@ -866,11 +907,11 @@ static irqreturn_t vdec_threaded_isr(int irq, void *data)
 }
 
 static const struct of_device_id vdec_dt_match[] = {
-	{ .compatible = "amlogic,meson-gxbb-vdec",
+	{ .compatible = "amlogic,gxbb-vdec",
 	  .data = &vdec_platform_gxbb },
-	{ .compatible = "amlogic,meson-gxm-vdec",
+	{ .compatible = "amlogic,gxm-vdec",
 	  .data = &vdec_platform_gxm },
-	{ .compatible = "amlogic,meson-gxl-vdec",
+	{ .compatible = "amlogic,gxl-vdec",
 	  .data = &vdec_platform_gxl },
 	{}
 };
@@ -1020,7 +1061,6 @@ static struct platform_driver meson_vdec_driver = {
 };
 module_platform_driver(meson_vdec_driver);
 
-MODULE_ALIAS("platform:meson-video-decoder");
 MODULE_DESCRIPTION("Meson video decoder driver for GXBB/GXL/GXM");
 MODULE_AUTHOR("Maxime Jourdan <maxi.jourdan@wanadoo.fr>");
-MODULE_LICENSE("GPL v2");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index fbcc731..82bcc46 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -67,6 +67,8 @@ struct vdec_codec_ops {
 	int (*stop)(struct vdec_session *sess);
 	int (*load_extended_firmware)(struct vdec_session *sess, const u8 *data, u32 len);
 	u32 (*num_pending_bufs)(struct vdec_session *sess);
+	int (*can_recycle)(struct vdec_core *core);
+	void (*recycle)(struct vdec_core *core, u32 buf_idx);
 	void (*notify_dst_buffer)(struct vdec_session *sess, struct vb2_buffer *vb);
 	irqreturn_t (*isr)(struct vdec_session *sess);
 	irqreturn_t (*threaded_isr)(struct vdec_session *sess);
@@ -132,6 +134,8 @@ struct vdec_session {
 	/* Buffers that need to be recycled by the HW */
 	struct list_head bufs_recycle;
 	struct mutex bufs_recycle_lock;
+	/* Thread for recycling buffers into the hardware */
+	struct task_struct *recycle_thread;
 	
 	/* Buffers queued into the HW */
 	struct list_head bufs;
-- 
2.7.4

