From 4e75935796180f524ee7f65fded0cde1d1a81715 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Sun, 12 Aug 2018 16:20:31 +0200
Subject: [PATCH 7/7] Add support for V4L2_PIX_FMT_YUV420M

Most codecs can now output 3-plane YUV 4:2:0.

MJPEG is restricted to YUV420M as it fails with NV12M.
HEVC is restricted to NV12M as it doesn't support YUV420M (for now)
---
 drivers/media/platform/meson/vdec/codec_h264.c    |  3 --
 drivers/media/platform/meson/vdec/codec_helpers.c | 62 +++++++++++++++++++++-
 drivers/media/platform/meson/vdec/codec_mjpeg.c   |  3 --
 drivers/media/platform/meson/vdec/codec_mpeg12.c  |  3 --
 drivers/media/platform/meson/vdec/codec_mpeg4.c   |  3 --
 drivers/media/platform/meson/vdec/vdec.c          | 63 +++++++++++++++++------
 drivers/media/platform/meson/vdec/vdec_1.c        |  4 ++
 drivers/media/platform/meson/vdec/vdec_platform.c | 12 +++++
 8 files changed, 125 insertions(+), 28 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_h264.c b/drivers/media/platform/meson/vdec/codec_h264.c
index 7dffd59..a54247a 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.c
+++ b/drivers/media/platform/meson/vdec/codec_h264.c
@@ -153,9 +153,6 @@ static int codec_h264_start(struct vdec_session *sess) {
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_CLR_REG);
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_MASK);
 
-	/* Enable 2-plane output */
-	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
-
 	writel_relaxed(0x404038aa, core->dos_base + MDEC_PIC_DC_THRESH);
 	
 	writel_relaxed((1<<12)|(1<<11), core->dos_base + DOS_SW_RESET0);
diff --git a/drivers/media/platform/meson/vdec/codec_helpers.c b/drivers/media/platform/meson/vdec/codec_helpers.c
index 9906433..eccfc34 100644
--- a/drivers/media/platform/meson/vdec/codec_helpers.c
+++ b/drivers/media/platform/meson/vdec/codec_helpers.c
@@ -9,7 +9,51 @@
 #include "codec_helpers.h"
 #include "canvas.h"
 
-void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base)
+void
+codec_helper_set_canvases_yuv420m(struct vdec_session *sess, void *reg_base)
+{
+	struct vdec_core *core = sess->core;
+	u32 width = ALIGN(sess->width, 64);
+	u32 height = ALIGN(sess->height, 64);
+	struct v4l2_m2m_buffer *buf;
+
+	/* Setup YUV420 canvases for Decoded Picture Buffer (dpb)
+	 * Map them to the user buffers' planes
+	 */
+	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
+		u32 buf_idx    = buf->vb.vb2_buf.index;
+		u32 cnv_y_idx  = 128 + buf_idx * 3;
+		u32 cnv_u_idx = cnv_y_idx + 1;
+		u32 cnv_v_idx = cnv_y_idx + 2;
+		dma_addr_t buf_y_paddr  =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+		dma_addr_t buf_u_paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 1);
+		dma_addr_t buf_v_paddr =
+			vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 2);
+
+		/* Y plane */
+		vdec_canvas_setup(core->dmc_base, cnv_y_idx, buf_y_paddr,
+			width, height, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
+
+		/* U plane */
+		vdec_canvas_setup(core->dmc_base, cnv_u_idx, buf_u_paddr,
+			width / 2, height / 2, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
+
+		/* V plane */
+		vdec_canvas_setup(core->dmc_base, cnv_v_idx, buf_v_paddr,
+			width / 2, height / 2, MESON_CANVAS_WRAP_NONE,
+			MESON_CANVAS_BLKMODE_LINEAR);
+
+		writel_relaxed(((cnv_v_idx) << 16) |
+			       ((cnv_u_idx) << 8)  |
+				(cnv_y_idx), reg_base + buf_idx * 4);
+	}
+}
+
+void codec_helper_set_canvases_nv12m(struct vdec_session *sess, void *reg_base)
 {
 	struct vdec_core *core = sess->core;
 	u32 width = ALIGN(sess->width, 64);
@@ -42,4 +86,20 @@ void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base)
 			       ((cnv_uv_idx) << 8)  |
 				(cnv_y_idx), reg_base + buf_idx * 4);
 	}
+}
+
+void codec_helper_set_canvases(struct vdec_session *sess, void *reg_base)
+{
+	u32 pixfmt = sess->fmt_cap->pixfmt;
+
+	switch (pixfmt) {
+	case V4L2_PIX_FMT_NV12M:
+		codec_helper_set_canvases_nv12m(sess, reg_base);
+		break;
+	case V4L2_PIX_FMT_YUV420M:
+		codec_helper_set_canvases_yuv420m(sess, reg_base);
+		break;
+	default:
+		dev_err(sess->core->dev, "Unsupported pixfmt %08X\n", pixfmt);
+	};
 }
\ No newline at end of file
diff --git a/drivers/media/platform/meson/vdec/codec_mjpeg.c b/drivers/media/platform/meson/vdec/codec_mjpeg.c
index 7553de0..3da333f 100644
--- a/drivers/media/platform/meson/vdec/codec_mjpeg.c
+++ b/drivers/media/platform/meson/vdec/codec_mjpeg.c
@@ -123,9 +123,6 @@ static int codec_mjpeg_start(struct vdec_session *sess)
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_MASK);
 	writel_relaxed(8, core->dos_base + VDEC_ASSIST_AMR1_INT8);
 
-	/* Enable 2-plane output */
-	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
-
 	return 0;
 }
 
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg12.c b/drivers/media/platform/meson/vdec/codec_mpeg12.c
index 0a07cee..c2370c9 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg12.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg12.c
@@ -97,9 +97,6 @@ static int codec_mpeg12_start(struct vdec_session *sess) {
 	writel_relaxed(0, core->dos_base + MREG_FATAL_ERROR);
 	writel_relaxed(0, core->dos_base + MREG_WAIT_BUFFER);
 
-	/* Enable NV21 */
-	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
-
 	return 0;
 
 free_mpeg12:
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg4.c b/drivers/media/platform/meson/vdec/codec_mpeg4.c
index 3093946..ccebadf 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg4.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg4.c
@@ -130,9 +130,6 @@ static int codec_mpeg4_start(struct vdec_session *sess) {
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_MASK);
 	writel_relaxed(0x404038aa, core->dos_base + MDEC_PIC_DC_THRESH);
 
-	/* Enable NV21 */
-	writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
-
 	return 0;
 
 free_mpeg4:
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 135f12e..e016e71 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -159,8 +159,14 @@ static int vdec_queue_setup(struct vb2_queue *q,
 		*num_planes = fmt_out->num_planes;
 		break;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
-		sizes[0] = vdec_get_output_size(sess);
-		sizes[1] = vdec_get_output_size(sess) / 2;
+		if (fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M) {
+			sizes[0] = vdec_get_output_size(sess);
+			sizes[1] = vdec_get_output_size(sess) / 2;
+		} else if (fmt_cap->pixfmt == V4L2_PIX_FMT_YUV420M) {
+			sizes[0] = vdec_get_output_size(sess);
+			sizes[1] = vdec_get_output_size(sess) / 4;
+			sizes[2] = vdec_get_output_size(sess) / 4;
+		}
 		*num_planes = fmt_cap->num_planes;
 		*num_buffers = min(max(*num_buffers, fmt_out->min_buffers), fmt_out->max_buffers);
 		sess->num_output_bufs = *num_buffers;
@@ -341,15 +347,26 @@ find_format_by_index(const struct vdec_format *fmts, u32 size, u32 index, u32 ty
 }
 
 static const struct vdec_format *
-vdec_try_fmt_common(const struct vdec_format *fmts, u32 size, struct v4l2_format *f)
+vdec_try_fmt_common(struct vdec_session *sess, u32 size, struct v4l2_format *f)
 {
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
 	struct v4l2_plane_pix_format *pfmt = pixmp->plane_fmt;
+	const struct vdec_format *fmts = sess->core->platform->formats;
 	const struct vdec_format *fmt;
 
 	memset(pfmt[0].reserved, 0, sizeof(pfmt[0].reserved));
 	memset(pixmp->reserved, 0, sizeof(pixmp->reserved));
 
+	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		/* hack: MJPEG only supports YUV420M */
+		if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_MJPEG)
+			pixmp->pixelformat = V4L2_PIX_FMT_YUV420M;
+
+		/* hack: HEVC only supports NV12M */
+		if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_HEVC)
+			pixmp->pixelformat = V4L2_PIX_FMT_NV12M;
+	}
+
 	fmt = find_format(fmts, size, pixmp->pixelformat, f->type);
 	if (!fmt) {
 		if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
@@ -375,13 +392,30 @@ vdec_try_fmt_common(const struct vdec_format *fmts, u32 size, struct v4l2_format
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
 		memset(pfmt[1].reserved, 0, sizeof(pfmt[1].reserved));
-		pfmt[0].sizeimage = get_output_size(pixmp->width, pixmp->height);
-		pfmt[0].bytesperline = ALIGN(pixmp->width, 64);
-
-		pfmt[1].sizeimage = get_output_size(pixmp->width, pixmp->height) / 2;
-		pfmt[1].bytesperline = ALIGN(pixmp->width, 64);
+		if (pixmp->pixelformat == V4L2_PIX_FMT_NV12M) {
+			pfmt[0].sizeimage =
+				get_output_size(pixmp->width, pixmp->height);
+			pfmt[0].bytesperline = ALIGN(pixmp->width, 64);
+
+			pfmt[1].sizeimage =
+			      get_output_size(pixmp->width, pixmp->height) / 2;
+			pfmt[1].bytesperline = ALIGN(pixmp->width, 64);
+		} else if (pixmp->pixelformat == V4L2_PIX_FMT_YUV420M) {
+			pfmt[0].sizeimage =
+				get_output_size(pixmp->width, pixmp->height);
+			pfmt[0].bytesperline = ALIGN(pixmp->width, 64);
+
+			pfmt[1].sizeimage =
+			      get_output_size(pixmp->width, pixmp->height) / 4;
+			pfmt[1].bytesperline = ALIGN(pixmp->width, 64) / 2;
+
+			pfmt[2].sizeimage =
+			      get_output_size(pixmp->width, pixmp->height) / 4;
+			pfmt[2].bytesperline = ALIGN(pixmp->width, 64) / 2;
+		}
 	} else {
-		pfmt[0].sizeimage = get_output_size(pixmp->width, pixmp->height);
+		pfmt[0].sizeimage =
+			get_output_size(pixmp->width, pixmp->height);
 		pfmt[0].bytesperline = 0;
 	}
 
@@ -393,7 +427,7 @@ static int vdec_try_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
 
-	vdec_try_fmt_common(sess->core->platform->formats,
+	vdec_try_fmt_common(sess,
 		sess->core->platform->num_formats, f);
 
 	return 0;
@@ -424,7 +458,7 @@ static int vdec_g_fmt(struct file *file, void *fh, struct v4l2_format *f)
 		pixmp->height = sess->height;
 	}
 
-	vdec_try_fmt_common(sess->core->platform->formats, sess->core->platform->num_formats, f);
+	vdec_try_fmt_common(sess, sess->core->platform->num_formats, f);
 
 	return 0;
 }
@@ -433,7 +467,6 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 {
 	struct vdec_session *sess = container_of(file->private_data, struct vdec_session, fh);
 	struct v4l2_pix_format_mplane *pixmp = &f->fmt.pix_mp;
-	const struct vdec_format *formats = sess->core->platform->formats;
 	u32 num_formats = sess->core->platform->num_formats;
 	const struct vdec_format *fmt;
 	struct v4l2_pix_format_mplane orig_pixmp;
@@ -442,7 +475,7 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 
 	orig_pixmp = *pixmp;
 
-	fmt = vdec_try_fmt_common(formats, num_formats, f);
+	fmt = vdec_try_fmt_common(sess, num_formats, f);
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		pixfmt_out = pixmp->pixelformat;
@@ -458,7 +491,7 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 	format.fmt.pix_mp.pixelformat = pixfmt_out;
 	format.fmt.pix_mp.width = orig_pixmp.width;
 	format.fmt.pix_mp.height = orig_pixmp.height;
-	vdec_try_fmt_common(formats, num_formats, &format);
+	vdec_try_fmt_common(sess, num_formats, &format);
 
 	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
 		sess->width = format.fmt.pix_mp.width;
@@ -475,7 +508,7 @@ static int vdec_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
 	format.fmt.pix_mp.pixelformat = pixfmt_cap;
 	format.fmt.pix_mp.width = orig_pixmp.width;
 	format.fmt.pix_mp.height = orig_pixmp.height;
-	vdec_try_fmt_common(formats, num_formats, &format);
+	vdec_try_fmt_common(sess, num_formats, &format);
 
 	sess->width = format.fmt.pix_mp.width;
 	sess->height = format.fmt.pix_mp.height;
diff --git a/drivers/media/platform/meson/vdec/vdec_1.c b/drivers/media/platform/meson/vdec/vdec_1.c
index f3bc186..e221f31 100644
--- a/drivers/media/platform/meson/vdec/vdec_1.c
+++ b/drivers/media/platform/meson/vdec/vdec_1.c
@@ -205,6 +205,10 @@ static int vdec_1_start(struct vdec_session *sess)
 
 	codec_ops->start(sess);
 
+	/* Enable 2-plane output */
+	if (sess->fmt_cap->pixfmt == V4L2_PIX_FMT_NV12M)
+		writel_relaxed(readl_relaxed(core->dos_base + MDEC_PIC_DC_CTRL) | (1 << 17), core->dos_base + MDEC_PIC_DC_CTRL);
+
 	/* Enable firmware processor */
 	writel_relaxed(1, core->dos_base + MPSR);
 	/* Let the firmware settle */
diff --git a/drivers/media/platform/meson/vdec/vdec_platform.c b/drivers/media/platform/meson/vdec/vdec_platform.c
index 92b7e45..284fe0e 100644
--- a/drivers/media/platform/meson/vdec/vdec_platform.c
+++ b/drivers/media/platform/meson/vdec/vdec_platform.c
@@ -20,6 +20,10 @@ static const struct vdec_format vdec_formats_gxbb[] = {
 		.num_planes = 2,
 		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
 	}, {
+		.pixfmt = V4L2_PIX_FMT_YUV420M,
+		.num_planes = 3,
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.num_planes = 1,
 		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
@@ -100,6 +104,10 @@ static const struct vdec_format vdec_formats_gxl[] = {
 		.num_planes = 2,
 		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
 	}, {
+		.pixfmt = V4L2_PIX_FMT_YUV420M,
+		.num_planes = 3,
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.num_planes = 1,
 		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
@@ -180,6 +188,10 @@ static const struct vdec_format vdec_formats_gxm[] = {
 		.num_planes = 2,
 		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
 	}, {
+		.pixfmt = V4L2_PIX_FMT_YUV420M,
+		.num_planes = 3,
+		.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE,
+	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.num_planes = 1,
 		.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
-- 
2.7.4

