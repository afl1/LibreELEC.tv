From c7e1d8d177de26e96e868b633de980508c296ac0 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Tue, 14 Aug 2018 01:45:17 +0200
Subject: [PATCH 10/11] Don't recycle the buffers too early

It's a bit of a hack to prevent CAPTURE buffers from being sent to the HW
right after they get queued.

Also included are some small refactors..
---
 drivers/media/platform/meson/vdec/vdec.c | 46 +++++++++++++++++---------------
 drivers/media/platform/meson/vdec/vdec.h |  9 +++++--
 2 files changed, 32 insertions(+), 23 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index 9f0ca5f..f16d8f3 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -56,19 +56,22 @@ static int vdec_recycle_thread(void *data)
 	struct vdec_session *sess = data;
 	struct vdec_core *core = sess->core;
 	struct vdec_codec_ops *codec_ops = sess->fmt_out->codec_ops;
-	struct vdec_buffer *tmp;
+	struct vdec_buffer *tmp, *n;
 
 	while (!kthread_should_stop()) {
 		mutex_lock(&sess->bufs_recycle_lock);
-		while (!list_empty(&sess->bufs_recycle) &&
-		       codec_ops->can_recycle(core))
-		{
-			tmp = list_first_entry(&sess->bufs_recycle,
-					       struct vdec_buffer, list);
-			codec_ops->recycle(core, tmp->index);
-			dev_dbg(core->dev, "Buffer %d recycled\n", tmp->index);
+
+		list_for_each_entry_safe(tmp, n, &sess->bufs_recycle, list) {
+			if (!codec_ops->can_recycle(core) ||
+			    sess->num_recycle < 2)
+				break;
+
+			codec_ops->recycle(core, tmp->vb->index);
+			dev_dbg(core->dev, "Buffer %d recycled\n",
+				tmp->vb->index);
 			list_del(&tmp->list);
 			kfree(tmp);
+			sess->num_recycle--;
 		}
 		mutex_unlock(&sess->bufs_recycle_lock);
 
@@ -120,10 +123,11 @@ void vdec_queue_recycle(struct vdec_session *sess, struct vb2_buffer *vb)
 	struct vdec_buffer *new_buf;
 
 	new_buf = kmalloc(sizeof(struct vdec_buffer), GFP_KERNEL);
-	new_buf->index = vb->index;
+	new_buf->vb = vb;
 
 	mutex_lock(&sess->bufs_recycle_lock);
 	list_add_tail(&new_buf->list, &sess->bufs_recycle);
+	sess->num_recycle++;
 	mutex_unlock(&sess->bufs_recycle_lock);
 }
 
@@ -232,6 +236,7 @@ static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 		goto vififo_free;
 
 	sess->sequence_cap = 0;
+	sess->num_recycle = 0;
 	if (vdec_codec_needs_recycle(sess))
 		sess->recycle_thread = kthread_run(vdec_recycle_thread, sess,
 						   "vdec_recycle");
@@ -786,7 +791,7 @@ static int vdec_close(struct file *file)
 void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 {
 	unsigned long flags;
-	struct vdec_buffer *tmp;
+	struct vdec_timestamp *tmp;
 	struct device *dev = sess->core->dev_dec;
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
@@ -799,11 +804,11 @@ void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 		goto unlock;
 	}
 
-	tmp = list_first_entry(&sess->bufs, struct vdec_buffer, list);
+	tmp = list_first_entry(&sess->bufs, struct vdec_timestamp, list);
 
 	vbuf->vb2_buf.planes[0].bytesused = vdec_get_output_size(sess);
 	vbuf->vb2_buf.planes[1].bytesused = vdec_get_output_size(sess) / 2;
-	vbuf->vb2_buf.timestamp = tmp->timestamp;
+	vbuf->vb2_buf.timestamp = tmp->ts;
 	vbuf->sequence = sess->sequence_cap++;
 
 	list_del(&tmp->list);
@@ -863,17 +868,16 @@ void vdec_dst_buf_done_idx(struct vdec_session *sess, u32 buf_idx)
 	vdec_dst_buf_done(sess, vbuf);
 }
 
-/* Userspace will queue timestamps that are not
+/* Userspace will queue src buffer timestamps that are not
  * in chronological order. Rearrange them here.
  */
 void vdec_add_ts_reorder(struct vdec_session *sess, u64 ts)
 {
-	struct vdec_buffer *new_buf, *tmp;
+	struct vdec_timestamp *new_ts, *tmp;
 	unsigned long flags;
 
-	new_buf = kmalloc(sizeof(*new_buf), GFP_KERNEL);
-	new_buf->timestamp = ts;
-	new_buf->index = -1;
+	new_ts = kmalloc(sizeof(*new_ts), GFP_KERNEL);
+	new_ts->ts = ts;
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
 
@@ -881,14 +885,14 @@ void vdec_add_ts_reorder(struct vdec_session *sess, u64 ts)
 		goto add_core;
 
 	list_for_each_entry(tmp, &sess->bufs, list) {
-		if (ts < tmp->timestamp) {
-			list_add_tail(&new_buf->list, &tmp->list);
+		if (ts < tmp->ts) {
+			list_add_tail(&new_ts->list, &tmp->list);
 			goto unlock;
 		}
 	}
 
 add_core:
-	list_add_tail(&new_buf->list, &sess->bufs);
+	list_add_tail(&new_ts->list, &sess->bufs);
 unlock:
 	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
 }
@@ -900,7 +904,7 @@ void vdec_remove_ts(struct vdec_session *sess, u64 ts)
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
 	list_for_each_entry(tmp, &sess->bufs, list) {
-		if (tmp->timestamp == ts) {
+		if (tmp->vb->timestamp == ts) {
 			list_del(&tmp->list);
 			kfree(tmp);
 			goto unlock;
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index 82bcc46..9321f62 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -23,8 +23,12 @@ struct dummy_buf {
 
 struct vdec_buffer {
 	struct list_head list;
-	s32 index;
-	u64 timestamp;
+	struct vb2_buffer *vb;
+};
+
+struct vdec_timestamp {
+	struct list_head list;
+	u64 ts;
 };
 
 struct vdec_session;
@@ -134,6 +138,7 @@ struct vdec_session {
 	/* Buffers that need to be recycled by the HW */
 	struct list_head bufs_recycle;
 	struct mutex bufs_recycle_lock;
+	unsigned int num_recycle;
 	/* Thread for recycling buffers into the hardware */
 	struct task_struct *recycle_thread;
 	
-- 
2.7.4

