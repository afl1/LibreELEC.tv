From d3f4ec6eb2b8b349284010f71e158002e765c9fd Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <maxi.jourdan@wanadoo.fr>
Date: Tue, 14 Aug 2018 14:12:42 +0200
Subject: [PATCH 11/11] Wait for the first keyframe before accounting for
 anything

Drop the src packets' timestamps and don't count them in
until we get a keyframe (or at least something that triggers the decoder).

This fixes usecases where userspace doesn't start with a keyframe, but
instead things like P/B frames. Typical for livestreams.

Concrete example: fixes the twitch app on kodi.
---
 drivers/media/platform/meson/vdec/codec_h264.c   |  5 +++--
 drivers/media/platform/meson/vdec/codec_hevc.c   |  1 +
 drivers/media/platform/meson/vdec/codec_mjpeg.c  |  3 +++
 drivers/media/platform/meson/vdec/codec_mpeg12.c |  1 +
 drivers/media/platform/meson/vdec/codec_mpeg4.c  |  1 +
 drivers/media/platform/meson/vdec/esparser.c     | 25 +++++++++++++++---------
 drivers/media/platform/meson/vdec/vdec.c         |  7 ++++---
 drivers/media/platform/meson/vdec/vdec.h         |  3 +++
 8 files changed, 32 insertions(+), 14 deletions(-)

diff --git a/drivers/media/platform/meson/vdec/codec_h264.c b/drivers/media/platform/meson/vdec/codec_h264.c
index a54247a..bb5a711 100644
--- a/drivers/media/platform/meson/vdec/codec_h264.c
+++ b/drivers/media/platform/meson/vdec/codec_h264.c
@@ -219,6 +219,8 @@ static void codec_h264_set_param(struct vdec_session *sess) {
 	struct vdec_core *core = sess->core;
 	struct codec_h264 *h264 = sess->priv;
 
+	sess->keyframe_found = 1;
+
 	writel_relaxed(0, core->dos_base + AV_SCRATCH_7);
 	writel_relaxed(0, core->dos_base + AV_SCRATCH_8);
 	writel_relaxed(0, core->dos_base + AV_SCRATCH_9);
@@ -261,12 +263,11 @@ static void codec_h264_set_param(struct vdec_session *sess) {
 		vdec_abort(sess);
 		return;
 	}
+
 	/* Address to store the references' MVs ? */
 	writel_relaxed(h264->ref_paddr, core->dos_base + AV_SCRATCH_1);
-
 	/* End of ref MV */
 	writel_relaxed(h264->ref_paddr + h264->ref_size, core->dos_base + AV_SCRATCH_4);
-
 	writel_relaxed((max_reference_size << 24) | (actual_dpb_size << 16) | (max_dpb_size << 8), core->dos_base + AV_SCRATCH_0);
 }
 
diff --git a/drivers/media/platform/meson/vdec/codec_hevc.c b/drivers/media/platform/meson/vdec/codec_hevc.c
index a0a6cf1..ffd5617 100644
--- a/drivers/media/platform/meson/vdec/codec_hevc.c
+++ b/drivers/media/platform/meson/vdec/codec_hevc.c
@@ -1361,6 +1361,7 @@ static irqreturn_t codec_hevc_threaded_isr(struct vdec_session *sess)
 		goto unlock;
 	}
 
+	sess->keyframe_found = 1;
 	codec_hevc_fetch_rpm(sess);
 	if (codec_hevc_process_rpm(sess)) {
 		vdec_abort(sess);
diff --git a/drivers/media/platform/meson/vdec/codec_mjpeg.c b/drivers/media/platform/meson/vdec/codec_mjpeg.c
index 3da333f..05a9a70 100644
--- a/drivers/media/platform/meson/vdec/codec_mjpeg.c
+++ b/drivers/media/platform/meson/vdec/codec_mjpeg.c
@@ -123,6 +123,9 @@ static int codec_mjpeg_start(struct vdec_session *sess)
 	writel_relaxed(1, core->dos_base + ASSIST_MBOX1_MASK);
 	writel_relaxed(8, core->dos_base + VDEC_ASSIST_AMR1_INT8);
 
+	/* Intra-only codec */
+	sess->keyframe_found = 1;
+
 	return 0;
 }
 
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg12.c b/drivers/media/platform/meson/vdec/codec_mpeg12.c
index c2370c9..03da456 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg12.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg12.c
@@ -136,6 +136,7 @@ static irqreturn_t codec_mpeg12_isr(struct vdec_session *sess)
 	if ((reg >> 16) & 0xfe)
 		goto end;
 
+	sess->keyframe_found = 1;
 	buffer_index = ((reg & 0xf) - 1) & 7;
 	vdec_dst_buf_done_idx(sess, buffer_index);
 
diff --git a/drivers/media/platform/meson/vdec/codec_mpeg4.c b/drivers/media/platform/meson/vdec/codec_mpeg4.c
index ccebadf..d4dfa6f 100644
--- a/drivers/media/platform/meson/vdec/codec_mpeg4.c
+++ b/drivers/media/platform/meson/vdec/codec_mpeg4.c
@@ -162,6 +162,7 @@ static irqreturn_t codec_mpeg4_isr(struct vdec_session *sess)
 
 	reg = readl_relaxed(core->dos_base + MREG_BUFFEROUT);
 	if (reg) {
+		sess->keyframe_found = 1;
 		readl_relaxed(core->dos_base + MP4_NOT_CODED_CNT);
 		readl_relaxed(core->dos_base + MP4_VOP_TIME_INC);
 		buffer_index = reg & 0x7;
diff --git a/drivers/media/platform/meson/vdec/esparser.c b/drivers/media/platform/meson/vdec/esparser.c
index 52369e2..45a140c 100644
--- a/drivers/media/platform/meson/vdec/esparser.c
+++ b/drivers/media/platform/meson/vdec/esparser.c
@@ -237,18 +237,27 @@ static int esparser_queue(struct vdec_session *sess, struct vb2_v4l2_buffer *vbu
 	ret = esparser_write_data(core, phy, payload_size + pad_size);
 
 	if (ret > 0) {
+		/* We need to wait until we parse/decode the first keyframe.
+		 * All buffers prior to the first keyframe must be dropped.
+		 */
+		if (!sess->keyframe_found)
+			usleep_range(1000, 2000);
+
+		if (sess->keyframe_found)
+			atomic_inc(&sess->esparser_queued_bufs);
+		else
+			vdec_remove_ts(sess, vb->timestamp);
+
 		vbuf->flags = 0;
 		vbuf->field = V4L2_FIELD_NONE;
 		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
-	} else if (ret <= 0) {
-		dev_warn(core->dev, "esparser: input parsing error\n");
-		vdec_remove_ts(sess, vb->timestamp);
-		v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
-		writel_relaxed(0, core->esparser_base + PARSER_FETCH_CMD);
+		return 0;
 	}
 
-	if (vbuf->flags & V4L2_BUF_FLAG_LAST)
-		esparser_queue_eos(sess);
+	dev_warn(core->dev, "esparser: input parsing error\n");
+	vdec_remove_ts(sess, vb->timestamp);
+	v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);
+	writel_relaxed(0, core->esparser_base + PARSER_FETCH_CMD);
 
 	return 0;
 }
@@ -263,8 +272,6 @@ void esparser_queue_all_src(struct work_struct *work)
 	v4l2_m2m_for_each_src_buf_safe(sess->m2m_ctx, buf, n) {
 		if (esparser_queue(sess, &buf->vb) < 0)
 			break;
-
-		atomic_inc(&sess->esparser_queued_bufs);
 	}
 	mutex_unlock(&sess->lock);
 }
diff --git a/drivers/media/platform/meson/vdec/vdec.c b/drivers/media/platform/meson/vdec/vdec.c
index f16d8f3..6f53075 100644
--- a/drivers/media/platform/meson/vdec/vdec.c
+++ b/drivers/media/platform/meson/vdec/vdec.c
@@ -237,6 +237,7 @@ static int vdec_start_streaming(struct vb2_queue *q, unsigned int count)
 
 	sess->sequence_cap = 0;
 	sess->num_recycle = 0;
+	sess->keyframe_found = 0;
 	if (vdec_codec_needs_recycle(sess))
 		sess->recycle_thread = kthread_run(vdec_recycle_thread, sess,
 						   "vdec_recycle");
@@ -822,11 +823,11 @@ void vdec_dst_buf_done(struct vdec_session *sess, struct vb2_v4l2_buffer *vbuf)
 	}
 
 	v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
+	atomic_dec(&sess->esparser_queued_bufs);
 
 unlock:
 	spin_unlock_irqrestore(&sess->bufs_spinlock, flags);
 
-	atomic_dec(&sess->esparser_queued_bufs);
 	/* Buffer done probably means the vififo got freed */
 	schedule_work(&sess->esparser_queue_work);
 }
@@ -899,12 +900,12 @@ void vdec_add_ts_reorder(struct vdec_session *sess, u64 ts)
 
 void vdec_remove_ts(struct vdec_session *sess, u64 ts)
 {
-	struct vdec_buffer *tmp;
+	struct vdec_timestamp *tmp;
 	unsigned long flags;
 
 	spin_lock_irqsave(&sess->bufs_spinlock, flags);
 	list_for_each_entry(tmp, &sess->bufs, list) {
-		if (tmp->vb->timestamp == ts) {
+		if (tmp->ts == ts) {
 			list_del(&tmp->list);
 			kfree(tmp);
 			goto unlock;
diff --git a/drivers/media/platform/meson/vdec/vdec.h b/drivers/media/platform/meson/vdec/vdec.h
index 9321f62..1a1d180 100644
--- a/drivers/media/platform/meson/vdec/vdec.h
+++ b/drivers/media/platform/meson/vdec/vdec.h
@@ -130,6 +130,9 @@ struct vdec_session {
 	 */
 	unsigned int should_stop;
 
+	/* Is set to 1 once the first keyframe has been parsed/decodeed */
+	unsigned int keyframe_found;
+
 	/* Big contiguous area for the VIFIFO */
 	void *vififo_vaddr;
 	dma_addr_t vififo_paddr;
-- 
2.7.4

