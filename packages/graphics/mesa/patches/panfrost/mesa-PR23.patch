From 2a5f350b1f25148e46ef25c82c2dafbc246e2fe9 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Tue, 8 Jan 2019 04:29:31 +0000
Subject: [PATCH 01/45] midgard: Lower rect textures

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 80e5a07d58..f8f37256c2 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -655,6 +655,12 @@ optimise_nir(nir_shader *nir)
         NIR_PASS(progress, nir, nir_lower_regs_to_ssa);
         NIR_PASS(progress, nir, midgard_nir_lower_fdot2);
 
+        nir_lower_tex_options lower_tex_options = {
+                .lower_rect = true
+        };
+
+        NIR_PASS(progress, nir, nir_lower_tex, &lower_tex_options);
+
         do {
                 progress = false;
 
-- 
2.18.1


From 061351a53f2dcc76030fcec2de91cab9ed758205 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Tue, 8 Jan 2019 05:41:11 +0000
Subject: [PATCH 02/45] Trek toward G-S

---
 .../drivers/panfrost/midgard/midgard_compile.c     | 14 ++++++++++----
 src/gallium/drivers/panfrost/pan_context.c         |  2 +-
 2 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index f8f37256c2..91803da967 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -3284,7 +3284,13 @@ midgard_compile_shader_nir(nir_shader *nir, midgard_program *program, bool is_bl
         nir_foreach_variable(var, &nir->uniforms) {
                 if (glsl_get_base_type(var->type) == GLSL_TYPE_SAMPLER) continue;
 
-                for (int col = 0; col < glsl_get_matrix_columns(var->type); ++col) {
+                unsigned length = glsl_get_length(var->type);
+
+                if (!length) {
+                        length = glsl_get_matrix_columns(var->type);
+                }
+
+                for (int col = 0; col < length; ++col) {
                         int id = ctx->uniform_count++;
                         _mesa_hash_table_u64_insert(ctx->uniform_nir_to_mdg, var->data.driver_location + col + 1, (void *) ((uintptr_t) (id + 1)));
                 }
@@ -3296,10 +3302,10 @@ midgard_compile_shader_nir(nir_shader *nir, midgard_program *program, bool is_bl
 
                 nir_foreach_variable(var, &nir->outputs) {
                         if (var->data.location < VARYING_SLOT_VAR0) {
-                                if (var->data.location == VARYING_SLOT_POS)
+                                if (var->data.location == VARYING_SLOT_POS) {
                                         _mesa_hash_table_u64_insert(ctx->varying_nir_to_mdg, var->data.driver_location + 1, (void *) ((uintptr_t) (1)));
-
-                                continue;
+                                        continue;
+                                }
                         }
 
                         for (int col = 0; col < glsl_get_matrix_columns(var->type); ++col) {
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 0e6ce7bd2c..bf2f6a6019 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2492,7 +2492,7 @@ panfrost_bind_depth_stencil_state(struct pipe_context *pipe,
                 return;
 
         /* Alpha does not exist on ES2... */
-        assert(!depth_stencil->alpha.enabled);
+        //assert(!depth_stencil->alpha.enabled);
 
         /* Stencil state */
         SET_BIT(ctx->fragment_shader_core.unknown2_4, MALI_STENCIL_TEST, depth_stencil->stencil[0].enabled); /* XXX: which one? */
-- 
2.18.1


From 886170789bfed272828e8fa4e8374f017cd2e2dd Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Tue, 8 Jan 2019 06:25:36 +0000
Subject: [PATCH 03/45] Allow STK to come online

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 2 +-
 src/gallium/drivers/panfrost/pan_screen.c              | 3 +++
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 91803da967..da00470718 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -1418,7 +1418,7 @@ emit_tex(compiler_context *ctx, nir_tex_instr *instr)
 
                 default: {
                         printf("Unknown source type\n");
-                        assert(0);
+                        //assert(0);
                         break;
                 }
                 }
diff --git a/src/gallium/drivers/panfrost/pan_screen.c b/src/gallium/drivers/panfrost/pan_screen.c
index e7aaf34ecc..0e2d5c6389 100644
--- a/src/gallium/drivers/panfrost/pan_screen.c
+++ b/src/gallium/drivers/panfrost/pan_screen.c
@@ -212,6 +212,9 @@ panfrost_get_param(struct pipe_screen *screen, enum pipe_cap param)
         case PIPE_CAP_TEXTURE_MULTISAMPLE:
                 return 0;
 
+        case PIPE_CAP_MAX_VERTEX_ELEMENT_SRC_OFFSET:
+                return 0xffff;
+
         case PIPE_CAP_MIN_MAP_BUFFER_ALIGNMENT:
                 return 64;
 
-- 
2.18.1


From 9491c754045bb4e705f6bfd113c89c67e97a1460 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Wed, 9 Jan 2019 04:26:46 +0000
Subject: [PATCH 04/45] Emulate b2f32

---
 .../panfrost/midgard/midgard_compile.c        | 29 +++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index da00470718..44a7f3ffb2 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -1003,6 +1003,20 @@ emit_alu(compiler_context *ctx, nir_alu_instr *instr)
                 break;
         }
 
+        /* We don't have a native b2f32 instruction. Instead, like many GPUs,
+         * we exploit booleans as 0/~0 for false/true, and correspondingly AND
+         * by 1.0 to do the type conversion. For the moment, prime us to emit:
+         *
+         * iand [whatever], #0
+         *
+         * At the end of emit_alu (as MIR), we'll fix-up the constant */
+
+        case nir_op_b2f32: {
+                op = midgard_alu_op_iand;
+                components = 0;
+                break;
+        }
+
         default:
                 printf("Unhandled ALU op %s\n", nir_op_infos[instr->op].name);
                 assert(0);
@@ -1066,6 +1080,21 @@ emit_alu(compiler_context *ctx, nir_alu_instr *instr)
 
         ins.alu = alu;
 
+        /* Late fixup for emulated instructions */
+
+
+        if (instr->op == nir_op_b2f32) {
+                /* Presently, our second argument is an inline #0 constant.
+                 * Switch over to an embedded 1.0 constant (that can't fit
+                 * inline, since we're 32-bit, not 16-bit like the inline
+                 * constants) */
+
+                ins.ssa_args.inline_constant = false;
+                ins.ssa_args.src1 = SSA_FIXED_REGISTER(REGISTER_CONSTANT);
+                ins.has_constants = true;
+                ins.constants[0] = 1.0;
+        }
+
         if (_unit == UNIT_VLUT) {
                 /* To avoid duplicating the LUTs (we think?), LUT instructions can only
                  * operate as if they were scalars. Lower them here by changing the
-- 
2.18.1


From f9188beaf3acb7771541876ddfc8083d9048a7d7 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Wed, 9 Jan 2019 05:37:14 +0000
Subject: [PATCH 05/45] Enable primconvert

---
 src/gallium/drivers/panfrost/pan_context.c | 26 +++++++++++++---------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index bf2f6a6019..fe0d325a7a 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1667,13 +1667,20 @@ panfrost_draw_vbo(
         /* Fallback for non-ES draw modes */
 
         if (info->mode >= PIPE_PRIM_QUADS) {
-                printf("XXX: Missing non-ES draw mode\n");
-                mode = PIPE_PRIM_TRIANGLE_FAN;
-                /*
-                util_primconvert_save_rasterizer_state(ctx->primconvert, &ctx->rasterizer->base);
-                util_primconvert_draw_vbo(ctx->primconvert, info);
-                printf("Fallback\n");
-                return; */
+                if (info->mode == PIPE_PRIM_QUADS && info->count == 4 && ctx->rasterizer && !ctx->rasterizer->base.flatshade) {
+                        mode = PIPE_PRIM_TRIANGLE_FAN;
+                } else {
+                        if (info->count < 4) {
+                                /* WTF */
+                                printf("WTF %d %d\n", info->count, info->mode);
+                                return;
+                        }
+                        printf("Fallback %d %d\n", info->count, info->mode);
+                        util_primconvert_save_rasterizer_state(ctx->primconvert, &ctx->rasterizer->base);
+                        util_primconvert_draw_vbo(ctx->primconvert, info);
+                        printf(":+1\n");
+                        return;
+                }
         }
 
         ctx->payload_tiler.prefix.draw_mode = g2m_draw_mode(mode);
@@ -1788,10 +1795,9 @@ panfrost_bind_rasterizer_state(
         struct panfrost_context *ctx = panfrost_context(pctx);
         struct pipe_rasterizer_state *cso = hwcso;
 
-        if (!hwcso) {
-                /* XXX: How to unbind rasterizer state? */
+        /* TODO: Why can't rasterizer be NULL ever? Other drivers are fine.. */
+        if (!hwcso)
                 return;
-        }
 
         /* If scissor test has changed, we'll need to update that now */
         bool update_scissor = !ctx->rasterizer || ctx->rasterizer->base.scissor != cso->scissor;
-- 
2.18.1


From 51ab4f931dd3db1a24c9e75b71c4e9e45bf52474 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Wed, 9 Jan 2019 06:08:41 +0000
Subject: [PATCH 06/45] Cleanup

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 1 -
 src/gallium/drivers/panfrost/pan_context.c             | 6 ++----
 2 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 44a7f3ffb2..d995702f4b 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -1082,7 +1082,6 @@ emit_alu(compiler_context *ctx, nir_alu_instr *instr)
 
         /* Late fixup for emulated instructions */
 
-
         if (instr->op == nir_op_b2f32) {
                 /* Presently, our second argument is an inline #0 constant.
                  * Switch over to an embedded 1.0 constant (that can't fit
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index fe0d325a7a..c31b48bfd9 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1671,14 +1671,12 @@ panfrost_draw_vbo(
                         mode = PIPE_PRIM_TRIANGLE_FAN;
                 } else {
                         if (info->count < 4) {
-                                /* WTF */
-                                printf("WTF %d %d\n", info->count, info->mode);
+                                /* Degenerate case? */
                                 return;
                         }
-                        printf("Fallback %d %d\n", info->count, info->mode);
+
                         util_primconvert_save_rasterizer_state(ctx->primconvert, &ctx->rasterizer->base);
                         util_primconvert_draw_vbo(ctx->primconvert, info);
-                        printf(":+1\n");
                         return;
                 }
         }
-- 
2.18.1


From 2a8b85d9a301e9c87859cd560e6cfbde72403b05 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Wed, 9 Jan 2019 07:02:57 +0000
Subject: [PATCH 07/45] Fix indexed draws

---
 .../drivers/panfrost/include/panfrost-job.h   | 13 +++--
 src/gallium/drivers/panfrost/pan_context.c    | 53 ++++++++++++++++---
 2 files changed, 53 insertions(+), 13 deletions(-)

diff --git a/src/gallium/drivers/panfrost/include/panfrost-job.h b/src/gallium/drivers/panfrost/include/panfrost-job.h
index 3667239ae3..6cadcb1a38 100644
--- a/src/gallium/drivers/panfrost/include/panfrost-job.h
+++ b/src/gallium/drivers/panfrost/include/panfrost-job.h
@@ -867,14 +867,17 @@ struct mali_vertex_tiler_prefix {
 
         /* Like many other strictly nonzero quantities, index_count is
          * subtracted by one. For an indexed cube, this is equal to 35 = 6
-         * faces * 2 triangles/per face * 3 vertices/per triangle - 1. For
-         * non-indexed draws, equal to vertex_count. */
+         * faces * 2 triangles/per face * 3 vertices/per triangle - 1. That is,
+         * for an indexed draw, index_count is the number of actual vertices
+         * rendered whereas invocation_count is the number of unique vertices
+         * rendered (the number of times the vertex shader must be invoked).
+         * For non-indexed draws, this is just equal to invocation_count. */
 
         u32 index_count;
 
-        /* No hidden structure; literally just a pointer to an array of
-         * uint32_t indices. Thanks, guys, for not making my life insane for
-         * once! NULL for non-indexed draws. */
+        /* No hidden structure; literally just a pointer to an array of uint
+         * indices (width depends on flags). Thanks, guys, for not making my
+         * life insane for once! NULL for non-indexed draws. */
 
         uintptr_t indices;
 } __attribute__((packed));
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index c31b48bfd9..27de5b9193 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1650,6 +1650,13 @@ panfrost_maybe_dummy_draw(struct panfrost_context *ctx, const struct pipe_draw_i
         dont_scanout = false;
 }
 
+#define CALCULATE_MIN_MAX_INDEX(T, buffer, start, count) \
+        for (unsigned _idx = (start); _idx < (start + count); ++_idx) { \
+                T idx = buffer[_idx]; \
+                if (idx > max_index) max_index = idx; \
+                if (idx < min_index) min_index = idx; \
+        }
+
 static void
 panfrost_draw_vbo(
         struct pipe_context *pipe,
@@ -1685,9 +1692,8 @@ panfrost_draw_vbo(
 
         ctx->vertex_count = info->count;
 
-        int invocation_count = info->index_size ? (info->start + ctx->vertex_count) : ctx->vertex_count;
-        ctx->payload_vertex.prefix.invocation_count = MALI_POSITIVE(invocation_count);
-        ctx->payload_tiler.prefix.invocation_count = MALI_POSITIVE(invocation_count);
+        /* For non-indexed draws, they're the same */
+        unsigned invocation_count = ctx->vertex_count;
 
         /* For higher amounts of vertices (greater than what fits in a 16-bit
          * short), the other value is needed, otherwise there will be bizarre
@@ -1697,10 +1703,39 @@ panfrost_draw_vbo(
         ctx->payload_tiler.prefix.unknown_draw |= (ctx->vertex_count > 65535) ? 0x3000 : 0x18000;
 
         if (info->index_size) {
+                /* Calculate the min/max index used so we can figure out how
+                 * many times to invoke the vertex shader */
+
 
-                ctx->payload_vertex.draw_start = 0;
-                ctx->payload_tiler.draw_start = 0;
-                //ctx->payload_tiler.prefix.negative_start = -info->start;
+                const uint8_t *ibuf8 = panfrost_get_index_buffer_raw(info);
+
+
+                int min_index = (1 << 30); /* Sentinel */
+                int max_index = 0;
+
+                if (info->index_size == 1) {
+                        CALCULATE_MIN_MAX_INDEX(uint8_t, ibuf8, info->start, info->count);
+                } else if (info->index_size == 2) {
+                        const uint16_t *ibuf16 = (const uint16_t *) ibuf8;
+                        CALCULATE_MIN_MAX_INDEX(uint16_t, ibuf16, info->start, info->count);
+                } else if (info->index_size == 4) {
+                        const uint32_t *ibuf32 = (const uint32_t *) ibuf8;
+                        CALCULATE_MIN_MAX_INDEX(uint32_t, ibuf32, info->start, info->count);
+                } else {
+                        assert(0);
+                }
+
+                /* Make sure we didn't go crazy */
+                assert(min_index < (1 << 30));
+                assert(max_index > 0);
+                assert(max_index > min_index);
+
+                /* Use the corresponding values */
+                invocation_count = max_index - min_index + 1;
+                ctx->payload_vertex.draw_start = min_index;
+                ctx->payload_tiler.draw_start = min_index;
+
+                ctx->payload_tiler.prefix.negative_start = /*-info->start*/ -min_index;
                 ctx->payload_tiler.prefix.index_count = MALI_POSITIVE(info->count);
 
                 //assert(!info->restart_index); /* TODO: Research */
@@ -1709,8 +1744,6 @@ panfrost_draw_vbo(
 
                 ctx->payload_tiler.prefix.unknown_draw |= panfrost_translate_index_size(info->index_size);
 
-                const uint8_t *ibuf8 = panfrost_get_index_buffer_raw(info);
-
                 ctx->payload_tiler.prefix.indices = panfrost_upload_transient(ctx, ibuf8 + (info->start * info->index_size), info->count * info->index_size);
         } else {
                 /* Index count == vertex count, if no indexing is applied, as
@@ -1724,6 +1757,10 @@ panfrost_draw_vbo(
                 ctx->payload_tiler.prefix.indices = (uintptr_t) NULL;
         }
 
+        ctx->payload_vertex.prefix.invocation_count = MALI_POSITIVE(invocation_count);
+        ctx->payload_tiler.prefix.invocation_count = MALI_POSITIVE(invocation_count);
+
+
         /* Fire off the draw itself */
         panfrost_queue_draw(ctx);
 }
-- 
2.18.1


From dc0c472bcb4135634af22cbcd2d73aeda0b073e2 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 03:35:41 +0000
Subject: [PATCH 08/45] Another fix, maybe

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 6 +++++-
 src/gallium/drivers/panfrost/pan_context.c             | 3 ++-
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index d995702f4b..7e2faa05f0 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -3312,7 +3312,11 @@ midgard_compile_shader_nir(nir_shader *nir, midgard_program *program, bool is_bl
         nir_foreach_variable(var, &nir->uniforms) {
                 if (glsl_get_base_type(var->type) == GLSL_TYPE_SAMPLER) continue;
 
-                unsigned length = glsl_get_length(var->type);
+                unsigned length = glsl_get_aoa_size(var->type);
+
+                if (!length) {
+                        length = glsl_get_length(var->type);
+                }
 
                 if (!length) {
                         length = glsl_get_matrix_columns(var->type);
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 27de5b9193..3b290e3290 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -996,7 +996,8 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
                 attrs[i].stride = buf->stride;
                 attrs[i].size = buf->stride * (ctx->payload_vertex.draw_start + ctx->vertex_count);
 
-                /* TODO: The above calculation is wrong. Do it better. For now, force resources */
+                /* TODO: The above calculation is wrong and breaks, e.g.
+                 * -bideas. Do it better. For now, force resources */
                 assert(!buf->is_user_buffer);
                 //attrs[i].size = buf->buffer.resource->width0 - buf->buffer_offset;
 
-- 
2.18.1


From d719546f31aa5b803118f6172a76f0befbd48ee5 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 03:37:57 +0000
Subject: [PATCH 09/45] Remove dated XXX

---
 src/gallium/drivers/panfrost/pan_context.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 3b290e3290..3274e4a6d8 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1212,7 +1212,6 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                         uint64_t trampolines[PIPE_MAX_SHADER_SAMPLER_VIEWS];
 
                         for (int i = 0; i < ctx->sampler_view_count[t]; ++i) {
-                                /* XXX: Why does this work? */
                                 if (!ctx->sampler_views[t][i])
                                         continue;
 
-- 
2.18.1


From ae9066564162800997dde2a8b5e8dba7eb17f586 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 03:42:12 +0000
Subject: [PATCH 10/45] Attribute buffer size depends on the invocation_count,
 not the vertex_count (differs for index draws)

---
 src/gallium/drivers/panfrost/pan_context.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 3274e4a6d8..7ffdbaebba 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -988,13 +988,15 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
         union mali_attr attrs[PIPE_MAX_ATTRIBS];
         union mali_attr varyings[PIPE_MAX_ATTRIBS];
 
+        unsigned invocation_count = MALI_NEGATIVE(ctx->payload_tiler.prefix.invocation_count);
+
         for (int i = 0; i < ctx->vertex_buffer_count; ++i) {
                 struct pipe_vertex_buffer *buf = &ctx->vertex_buffers[i];
                 struct panfrost_resource *rsrc = (struct panfrost_resource *) (buf->buffer.resource);
 
                 /* Offset vertex count by draw_start to make sure we upload enough */
                 attrs[i].stride = buf->stride;
-                attrs[i].size = buf->stride * (ctx->payload_vertex.draw_start + ctx->vertex_count);
+                attrs[i].size = buf->stride * (ctx->payload_vertex.draw_start + invocation_count);
 
                 /* TODO: The above calculation is wrong and breaks, e.g.
                  * -bideas. Do it better. For now, force resources */
@@ -1019,7 +1021,7 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
                 varyings[i].stride = ctx->vs->varyings.varyings_stride[i];
 
                 /* XXX: Why does adding an extra ~8000 vertices fix missing triangles in glmark2-es2 -bshadow? */
-                varyings[i].size = ctx->vs->varyings.varyings_stride[i] * MALI_NEGATIVE(ctx->payload_tiler.prefix.invocation_count);
+                varyings[i].size = ctx->vs->varyings.varyings_stride[i] * invocation_count;
 
                 /* gl_Position varying is always last by convention */
                 if ((i + 1) == ctx->vs->varyings.varying_buffer_count)
-- 
2.18.1


From 59d43f5710a871c2f473722641da55b007bd12ba Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 04:03:23 +0000
Subject: [PATCH 11/45] Tack on max_src_offset

---
 src/gallium/drivers/panfrost/pan_context.c | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 7ffdbaebba..d771f6719a 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -994,9 +994,27 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
                 struct pipe_vertex_buffer *buf = &ctx->vertex_buffers[i];
                 struct panfrost_resource *rsrc = (struct panfrost_resource *) (buf->buffer.resource);
 
+                /* Let's figure out the layout of the attributes in memory so
+                 * we can be smart about size computation. The idea is to
+                 * figure out the maximum src_offset, which tells us the latest
+                 * spot a vertex could start. Meanwhile, we figure out the size
+                 * of the attribute memory (assuming interleaved
+                 * representation) and tack on the max src_offset for a
+                 * reasonably good upper bound on the size.
+                 *
+                 * Proving correctness is left as an exercise to the reader.
+                 */
+
+                unsigned max_src_offset = 0;
+
+                for (unsigned j = 0; j < ctx->vertex->num_elements; ++j) {
+                        if (ctx->vertex->pipe[j].vertex_buffer_index != i) continue;
+                        max_src_offset = MAX2(max_src_offset, ctx->vertex->pipe[j].src_offset);
+                }
+
                 /* Offset vertex count by draw_start to make sure we upload enough */
                 attrs[i].stride = buf->stride;
-                attrs[i].size = buf->stride * (ctx->payload_vertex.draw_start + invocation_count);
+                attrs[i].size = buf->stride * (ctx->payload_vertex.draw_start + invocation_count) + max_src_offset;
 
                 /* TODO: The above calculation is wrong and breaks, e.g.
                  * -bideas. Do it better. For now, force resources */
-- 
2.18.1


From 58b583c1a9284f4157a53231cdd3b0635f53cf30 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 04:03:41 +0000
Subject: [PATCH 12/45] No longer need to force resources

---
 src/gallium/drivers/panfrost/pan_context.c | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index d771f6719a..b990e0e139 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1016,11 +1016,6 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
                 attrs[i].stride = buf->stride;
                 attrs[i].size = buf->stride * (ctx->payload_vertex.draw_start + invocation_count) + max_src_offset;
 
-                /* TODO: The above calculation is wrong and breaks, e.g.
-                 * -bideas. Do it better. For now, force resources */
-                assert(!buf->is_user_buffer);
-                //attrs[i].size = buf->buffer.resource->width0 - buf->buffer_offset;
-
                 /* Vertex elements are -already- GPU-visible, at
                  * rsrc->gpu. However, attribute buffers must be 64 aligned. If
                  * it is not, for now we have to duplicate the buffer. */
-- 
2.18.1


From 3fc150cffcc097514edc1d6aa348a1c558408ca0 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 04:44:08 +0000
Subject: [PATCH 13/45] Prepare for emulated alpha

---
 src/gallium/drivers/panfrost/pan_context.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index b990e0e139..417d7b5120 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2547,8 +2547,12 @@ panfrost_bind_depth_stencil_state(struct pipe_context *pipe,
         if (!depth_stencil)
                 return;
 
-        /* Alpha does not exist on ES2... */
-        //assert(!depth_stencil->alpha.enabled);
+        /* Alpha does not exist in the hardware (it's not in ES3), so it's
+         * emulated in the fragment shader */
+
+        if (depth_stencil->alpha.enabled) {
+               /* TODO: Custom shader */ 
+        }
 
         /* Stencil state */
         SET_BIT(ctx->fragment_shader_core.unknown2_4, MALI_STENCIL_TEST, depth_stencil->stencil[0].enabled); /* XXX: which one? */
-- 
2.18.1


From b0f8ead8f743f3efcd8e2da311eef8f182584daa Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 05:57:10 +0000
Subject: [PATCH 14/45] Format wish list?

---
 src/gallium/drivers/panfrost/pan_format.c | 10 ++++++++++
 src/gallium/drivers/panfrost/pan_screen.c |  4 ++++
 2 files changed, 14 insertions(+)

diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index 022d30089a..81b756e1a4 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -137,8 +137,17 @@ panfrost_translate_channel_type(unsigned type, unsigned size, bool norm) {
 enum mali_format
 panfrost_find_format(const struct util_format_description *desc)
 {
+        /* Find first non-VOID channel */
         struct util_format_channel_description chan = desc->channel[0];
 
+        for (unsigned c = 0; c < 4; ++c) {
+                if (desc->channel[c].type == UTIL_FORMAT_TYPE_VOID)
+                        continue;
+
+                chan = desc->channel[c];
+                break;
+        }
+
         /* Check for special formats */
         switch (desc->format) {
                 case PIPE_FORMAT_R10G10B10X2_UNORM:
@@ -172,6 +181,7 @@ panfrost_find_format(const struct util_format_description *desc)
         switch (chan.type) {
                 case UTIL_FORMAT_TYPE_UNSIGNED:
                 case UTIL_FORMAT_TYPE_SIGNED:
+                case UTIL_FORMAT_TYPE_FIXED:
                         /* Channel width */
                         format |= panfrost_translate_channel_width(chan.size);
 
diff --git a/src/gallium/drivers/panfrost/pan_screen.c b/src/gallium/drivers/panfrost/pan_screen.c
index 0e2d5c6389..85e68f8b39 100644
--- a/src/gallium/drivers/panfrost/pan_screen.c
+++ b/src/gallium/drivers/panfrost/pan_screen.c
@@ -558,6 +558,10 @@ panfrost_is_format_supported( struct pipe_screen *screen,
         if (sample_count > 1)
                 return FALSE;
 
+        /* Format wishlist */
+        if (format == PIPE_FORMAT_Z24X8_UNORM || format == PIPE_FORMAT_X8Z24_UNORM)
+                return FALSE;
+
         if (bind & PIPE_BIND_RENDER_TARGET) {
                 /* We don't support rendering into anything but RGBA8 yet. We
                  * need more formats for spec compliance, but for now, honesty
-- 
2.18.1


From 4eb2c10ca5b8668a0c790abef15a95289917be82 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 10 Jan 2019 23:49:05 +0000
Subject: [PATCH 15/45] Debug alpha

---
 src/gallium/drivers/panfrost/pan_context.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 417d7b5120..a6ca2cc6f1 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2551,6 +2551,7 @@ panfrost_bind_depth_stencil_state(struct pipe_context *pipe,
          * emulated in the fragment shader */
 
         if (depth_stencil->alpha.enabled) {
+                printf("%f with %d\n", depth_stencil->alpha.ref_value, depth_stencil->alpha.func);
                /* TODO: Custom shader */ 
         }
 
-- 
2.18.1


From c5eac697984b2c834d4b288ce10254b093713243 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Fri, 11 Jan 2019 00:10:07 +0000
Subject: [PATCH 16/45] Treat external textures as 2D (thank you ezequielg)

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 7e2faa05f0..7df3808668 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -1393,6 +1393,7 @@ midgard_tex_format(enum glsl_sampler_dim dim)
 {
         switch (dim) {
         case GLSL_SAMPLER_DIM_2D:
+        case GLSL_SAMPLER_DIM_EXTERNAL:
                 return TEXTURE_2D;
 
         case GLSL_SAMPLER_DIM_3D:
-- 
2.18.1


From 877e6b0d87733b284d09d01205394bd77adf4930 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Fri, 11 Jan 2019 04:17:57 +0000
Subject: [PATCH 17/45] Debug print for unknown format type

---
 src/gallium/drivers/panfrost/pan_format.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/gallium/drivers/panfrost/pan_format.c b/src/gallium/drivers/panfrost/pan_format.c
index 81b756e1a4..305e576161 100644
--- a/src/gallium/drivers/panfrost/pan_format.c
+++ b/src/gallium/drivers/panfrost/pan_format.c
@@ -198,6 +198,7 @@ panfrost_find_format(const struct util_format_description *desc)
                         break;
 
                 default:
+                        fprintf(stderr, "Unknown format type in %s\n", desc->name);
                         assert(0);
                         break;
         }
-- 
2.18.1


From a896cf7daf9610e603c90a7c52549aa04b52d23d Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Fri, 11 Jan 2019 05:00:40 +0000
Subject: [PATCH 18/45] Abstract away shader variants

---
 src/gallium/drivers/panfrost/pan_assemble.c |  2 +-
 src/gallium/drivers/panfrost/pan_context.c  | 93 +++++++++++++++------
 src/gallium/drivers/panfrost/pan_context.h  | 25 +++++-
 3 files changed, 92 insertions(+), 28 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_assemble.c b/src/gallium/drivers/panfrost/pan_assemble.c
index 0792619d5c..b103fe4c38 100644
--- a/src/gallium/drivers/panfrost/pan_assemble.c
+++ b/src/gallium/drivers/panfrost/pan_assemble.c
@@ -42,7 +42,7 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
 
         nir_shader *s;
 
-        struct pipe_shader_state *cso = &state->base;
+        struct pipe_shader_state *cso = state->base;
 
         if (cso->type == PIPE_SHADER_IR_NIR) {
                 s = cso->ir.nir;
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index a6ca2cc6f1..6c306ec94c 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -86,17 +86,19 @@ static bool FORCE_MSAA = true;
 static void
 panfrost_upload_varyings_descriptor(struct panfrost_context *ctx)
 {
+        struct panfrost_varyings *varyings = &ctx->vs->variants[ctx->vs->active_variant].varyings;
+
         /* First, upload gl_Position varyings */
-        mali_ptr gl_Position = panfrost_upload(&ctx->cmdstream_persistent, ctx->vs->varyings.vertex_only_varyings, sizeof(ctx->vs->varyings.vertex_only_varyings), true);
+        mali_ptr gl_Position = panfrost_upload(&ctx->cmdstream_persistent, varyings->vertex_only_varyings, sizeof(varyings->vertex_only_varyings), true);
 
         /* Then, upload normal varyings for vertex shaders */
-        panfrost_upload_sequential(&ctx->cmdstream_persistent, ctx->vs->varyings.varyings, sizeof(ctx->vs->varyings.varyings[0]) * ctx->vs->varyings.varying_count);
+        panfrost_upload_sequential(&ctx->cmdstream_persistent, varyings->varyings, sizeof(varyings->varyings[0]) * varyings->varying_count);
 
         /* Then, upload normal varyings for fragment shaders (duplicating) */
-        mali_ptr varyings_fragment = panfrost_upload_sequential(&ctx->cmdstream_persistent, ctx->vs->varyings.varyings, sizeof(ctx->vs->varyings.varyings[0]) * ctx->vs->varyings.varying_count);
+        mali_ptr varyings_fragment = panfrost_upload_sequential(&ctx->cmdstream_persistent, varyings->varyings, sizeof(varyings->varyings[0]) * varyings->varying_count);
 
         /* Finally, upload gl_FragCoord varying */
-        panfrost_upload_sequential(&ctx->cmdstream_persistent, ctx->vs->varyings.fragment_only_varyings, sizeof(ctx->vs->varyings.fragment_only_varyings[0]) * ctx->vs->varyings.fragment_only_varying_count);
+        panfrost_upload_sequential(&ctx->cmdstream_persistent, varyings->fragment_only_varyings, sizeof(varyings->fragment_only_varyings[0]) * varyings->fragment_only_varying_count);
 
         ctx->payload_vertex.postfix.varying_meta = gl_Position;
         ctx->payload_tiler.postfix.varying_meta = varyings_fragment;
@@ -1029,15 +1031,17 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
                 }
         }
 
-        for (int i = 0; i < ctx->vs->varyings.varying_buffer_count; ++i) {
+        struct panfrost_varyings *vars = &ctx->vs->variants[ctx->vs->active_variant].varyings;
+
+        for (int i = 0; i < vars->varying_buffer_count; ++i) {
                 varyings[i].elements = (ctx->varying_mem.gpu + ctx->varying_height) | 1;
-                varyings[i].stride = ctx->vs->varyings.varyings_stride[i];
+                varyings[i].stride = vars->varyings_stride[i];
 
                 /* XXX: Why does adding an extra ~8000 vertices fix missing triangles in glmark2-es2 -bshadow? */
-                varyings[i].size = ctx->vs->varyings.varyings_stride[i] * invocation_count;
+                varyings[i].size = vars->varyings_stride[i] * invocation_count;
 
                 /* gl_Position varying is always last by convention */
-                if ((i + 1) == ctx->vs->varyings.varying_buffer_count)
+                if ((i + 1) == vars->varying_buffer_count)
                         ctx->payload_tiler.postfix.position_varying = ctx->varying_mem.gpu + ctx->varying_height;
 
                 /* Varyings appear to need 64-byte alignment */
@@ -1049,7 +1053,7 @@ panfrost_emit_vertex_data(struct panfrost_context *ctx)
 
         ctx->payload_vertex.postfix.attributes = panfrost_upload_transient(ctx, attrs, ctx->vertex_buffer_count * sizeof(union mali_attr));
 
-        mali_ptr varyings_p = panfrost_upload_transient(ctx, &varyings, ctx->vs->varyings.varying_buffer_count * sizeof(union mali_attr));
+        mali_ptr varyings_p = panfrost_upload_transient(ctx, &varyings, vars->varying_buffer_count * sizeof(union mali_attr));
         ctx->payload_vertex.postfix.varyings = varyings_p;
         ctx->payload_tiler.postfix.varyings = varyings_p;
 }
@@ -1074,14 +1078,16 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
         if (ctx->dirty & PAN_DIRTY_VS) {
                 assert(ctx->vs);
 
+                struct panfrost_shader_state *vs = &ctx->vs->variants[ctx->vs->active_variant];
+
                 /* Late shader descriptor assignments */
-                ctx->vs->tripipe.texture_count = ctx->sampler_view_count[PIPE_SHADER_VERTEX];
-                ctx->vs->tripipe.sampler_count = ctx->sampler_count[PIPE_SHADER_VERTEX];
+                vs->tripipe.texture_count = ctx->sampler_view_count[PIPE_SHADER_VERTEX];
+                vs->tripipe.sampler_count = ctx->sampler_count[PIPE_SHADER_VERTEX];
 
                 /* Who knows */
-                ctx->vs->tripipe.midgard1.unknown1 = 0x2201;
+                vs->tripipe.midgard1.unknown1 = 0x2201;
 
-                ctx->payload_vertex.postfix._shader_upper = panfrost_upload(&ctx->cmdstream_persistent, &ctx->vs->tripipe, sizeof(struct mali_shader_meta), true) >> 4;
+                ctx->payload_vertex.postfix._shader_upper = panfrost_upload(&ctx->cmdstream_persistent, &vs->tripipe, sizeof(struct mali_shader_meta), true) >> 4;
 
                 /* Varying descriptor is tied to the vertex shader. Also the
                  * fragment shader, I suppose, but it's generated with the
@@ -1092,7 +1098,9 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
 
         if (ctx->dirty & PAN_DIRTY_FS) {
                 assert(ctx->fs);
-#define COPY(name) ctx->fragment_shader_core.name = ctx->fs->tripipe.name
+                struct panfrost_shader_state *variant = &ctx->fs->variants[ctx->fs->active_variant];
+
+#define COPY(name) ctx->fragment_shader_core.name = variant->tripipe.name
 
                 COPY(shader);
                 COPY(attribute_count);
@@ -1126,7 +1134,7 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                  * Is EGL_BUFFER_PRESERVED a good thing?" by Peter Harris
                  */
 
-                if (ctx->fs->can_discard) {
+                if (variant->can_discard) {
                         ctx->fragment_shader_core.unknown2_3 |= MALI_CAN_DISCARD;
                         ctx->fragment_shader_core.midgard1.unknown1 &= ~MALI_NO_ALPHA_TO_COVERAGE;
                         ctx->fragment_shader_core.midgard1.unknown1 |= 0x4000;
@@ -1310,12 +1318,12 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
 
                         switch (i) {
                         case PIPE_SHADER_VERTEX:
-                                uniform_count = ctx->vs->uniform_count;
+                                uniform_count = ctx->vs->variants[ctx->vs->active_variant].uniform_count;
                                 postfix = &ctx->payload_vertex.postfix;
                                 break;
 
                         case PIPE_SHADER_FRAGMENT:
-                                uniform_count = ctx->fs->uniform_count;
+                                uniform_count = ctx->fs->variants[ctx->fs->active_variant].uniform_count;
                                 postfix = &ctx->payload_tiler.postfix;
                                 break;
 
@@ -1905,7 +1913,7 @@ panfrost_create_shader_state(
         struct pipe_context *pctx,
         const struct pipe_shader_state *cso)
 {
-        struct panfrost_shader_state *so = CALLOC_STRUCT(panfrost_shader_state);
+        struct panfrost_shader_variants *so = CALLOC_STRUCT(panfrost_shader_variants);
         so->base = *cso;
 
         /* Token deep copy to prevent memory corruption */
@@ -1978,6 +1986,13 @@ panfrost_bind_sampler_states(
         ctx->dirty |= PAN_DIRTY_SAMPLERS;
 }
 
+static bool
+panfrost_variant_matches(struct panfrost_context *ctx, struct panfrost_shader_state *variant)
+{
+        /* STUB */
+        return true;
+}
+
 static void
 panfrost_bind_fs_state(
         struct pipe_context *pctx,
@@ -1988,9 +2003,38 @@ panfrost_bind_fs_state(
         ctx->fs = hwcso;
 
         if (hwcso) {
-                if (!ctx->fs->compiled) {
-                        panfrost_shader_compile(ctx, &ctx->fs->tripipe, NULL, JOB_TYPE_TILER, hwcso);
-                        ctx->fs->compiled = true;
+                /* Match the appropriate variant */
+
+                signed variant = -1;
+
+                struct panfrost_shader_variants *variants = (struct panfrost_shader_variants *) hwcso;
+
+                for (unsigned i = 0; i < variants->variant_count; ++i) {
+                        if (panfrost_variant_matches(ctx, &variants->variants[i])) {
+                                variant = i;
+                                break;
+                        }
+                }
+
+                if (variant == -1) {
+                        /* No variant matched, so create a new one */
+                        variant = variants->variant_count++;
+                        assert(variants->variant_count < MAX_SHADER_VARIANTS);
+
+                        variants->variants[variant].base = hwcso;
+                }
+
+                /* Select this variant */
+                variants->active_variant = variant;
+
+                struct panfrost_shader_state *shader_state = &variants->variants[variant];
+                assert(panfrost_variant_matches(ctx, shader_state));
+
+                /* Now we have a variant selected, so compile and go */
+
+                if (!shader_state->compiled) {
+                        panfrost_shader_compile(ctx, &shader_state->tripipe, NULL, JOB_TYPE_TILER, shader_state);
+                        shader_state->compiled = true;
                 }
         }
 
@@ -2007,9 +2051,10 @@ panfrost_bind_vs_state(
         ctx->vs = hwcso;
 
         if (hwcso) {
-                if (!ctx->vs->compiled) {
-                        panfrost_shader_compile(ctx, &ctx->vs->tripipe, NULL, JOB_TYPE_VERTEX, hwcso);
-                        ctx->vs->compiled = true;
+                if (!ctx->vs->variants[0].compiled) {
+                        ctx->vs->variants[0].base = hwcso;
+                        panfrost_shader_compile(ctx, &ctx->vs->variants[0].tripipe, NULL, JOB_TYPE_VERTEX, &ctx->vs->variants[0]);
+                        ctx->vs->variants[0].compiled = true;
                 }
         }
 
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 3e0619983c..4f7bf1df24 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -186,8 +186,8 @@ struct panfrost_context {
         /* CSOs */
         struct panfrost_rasterizer *rasterizer;
 
-        struct panfrost_shader_state *vs;
-        struct panfrost_shader_state *fs;
+        struct panfrost_shader_variants *vs;
+        struct panfrost_shader_variants *fs;
 
         struct panfrost_vertex_state *vertex;
 
@@ -259,8 +259,14 @@ struct panfrost_varyings {
         int fragment_only_varying_count;
 };
 
+/* Variants bundle together to form the backing CSO, bundling multiple
+ * shaders with varying emulated features baked in (alpha test
+ * parameters, etc) */
+#define MAX_SHADER_VARIANTS 8
+
+/* A shader state corresponds to the actual, current variant of the shader */
 struct panfrost_shader_state {
-        struct pipe_shader_state base;
+        struct pipe_shader_state *base;
 
         /* Compiled descriptor, ready for the hardware */
         bool compiled;
@@ -272,6 +278,19 @@ struct panfrost_shader_state {
 
         /* Valid for vertex shaders only due to when this is calculated */
         struct panfrost_varyings varyings;
+
+        /* Information on this particular shader variant */
+};
+
+/* A collection of varyings (the CSO) */
+struct panfrost_shader_variants {
+        struct pipe_shader_state base;
+
+        struct panfrost_shader_state variants[MAX_SHADER_VARIANTS];
+        unsigned variant_count;
+
+        /* The current active variant */
+        unsigned active_variant;
 };
 
 struct panfrost_vertex_state {
-- 
2.18.1


From 56787591531b98fe726507a8b0694636e59f50fc Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Fri, 11 Jan 2019 05:16:23 +0000
Subject: [PATCH 19/45] Make variants based on alpha

---
 src/gallium/drivers/panfrost/pan_context.c | 23 ++++++++++++++++++++--
 src/gallium/drivers/panfrost/pan_context.h |  1 +
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 6c306ec94c..ed85ff0823 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1989,7 +1989,23 @@ panfrost_bind_sampler_states(
 static bool
 panfrost_variant_matches(struct panfrost_context *ctx, struct panfrost_shader_state *variant)
 {
-        /* STUB */
+        struct pipe_alpha_state *alpha = &ctx->depth_stencil->alpha;
+
+        if (alpha->enabled || variant->alpha_state.enabled) {
+                /* Make sure enable state is at least the same */
+                if (alpha->enabled != variant->alpha_state.enabled) {
+                        return false;
+                }
+
+                /* Check that the contents of the test are the same */
+                bool same_func = alpha->func == variant->alpha_state.func;
+                bool same_ref = alpha->ref_value == variant->alpha_state.ref_value;
+
+                if (!(same_func && same_ref)) {
+                        return false;
+                }
+        }
+        /* Otherwise, we're good to go */
         return true;
 }
 
@@ -2022,6 +2038,7 @@ panfrost_bind_fs_state(
                         assert(variants->variant_count < MAX_SHADER_VARIANTS);
 
                         variants->variants[variant].base = hwcso;
+                        variants->variants[variant].alpha_state = ctx->depth_stencil->alpha;
                 }
 
                 /* Select this variant */
@@ -2597,7 +2614,9 @@ panfrost_bind_depth_stencil_state(struct pipe_context *pipe,
 
         if (depth_stencil->alpha.enabled) {
                 printf("%f with %d\n", depth_stencil->alpha.ref_value, depth_stencil->alpha.func);
-               /* TODO: Custom shader */ 
+
+                /* We need to trigger a new shader (maybe) */
+                ctx->base.bind_fs_state(&ctx->base, ctx->fs);
         }
 
         /* Stencil state */
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 4f7bf1df24..2205f2be07 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -280,6 +280,7 @@ struct panfrost_shader_state {
         struct panfrost_varyings varyings;
 
         /* Information on this particular shader variant */
+        struct pipe_alpha_state alpha_state;
 };
 
 /* A collection of varyings (the CSO) */
-- 
2.18.1


From 3cd449c18dff13aaddad7d7471eae75e057a0540 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Fri, 11 Jan 2019 05:30:58 +0000
Subject: [PATCH 20/45] First try at alpha test lowering

---
 .../drivers/panfrost/midgard/midgard_compile.c  | 17 +++++++++++++++++
 .../drivers/panfrost/midgard/midgard_compile.h  |  3 +++
 src/gallium/drivers/panfrost/pan_assemble.c     | 13 ++++++++++++-
 3 files changed, 32 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 7df3808668..debb1c253c 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -414,6 +414,9 @@ typedef struct compiler_context {
 
         /* Count of instructions emitted from NIR overall, across all blocks */
         int instruction_count;
+
+        /* Alpha ref value passed in */
+        float alpha_ref;
 } compiler_context;
 
 /* Append instruction to end of current block */
@@ -1381,6 +1384,18 @@ emit_intrinsic(compiler_context *ctx, nir_intrinsic_instr *instr)
 
                 break;
 
+        case nir_intrinsic_load_alpha_ref_float:
+                assert(instr->dest.is_ssa);
+
+                float ref_value = ctx->alpha_ref;
+                printf("Ref %f\n", ref_value);
+
+                float *v = ralloc_array(NULL, float, 4);
+                memcpy(v, &ref_value, sizeof(float));
+                _mesa_hash_table_u64_insert(ctx->ssa_constants, instr->dest.ssa.index + 1, v);
+                break;
+
+
         default:
                 printf ("Unhandled intrinsic\n");
                 assert(0);
@@ -3267,6 +3282,8 @@ midgard_compile_shader_nir(nir_shader *nir, midgard_program *program, bool is_bl
 
                 .is_blend = is_blend,
                 .blend_constant_offset = -1,
+
+                .alpha_ref = program->alpha_ref
         };
 
         compiler_context *ctx = &ictx;
diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.h b/src/gallium/drivers/panfrost/midgard/midgard_compile.h
index b6bc7904e2..7d4200919e 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.h
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.h
@@ -45,6 +45,9 @@ typedef struct {
          * negative, there's no constant. */
 
         int blend_patch_offset;
+
+        /* IN: For a fragment shader with a lowered alpha test, the ref value */
+        float alpha_ref;
 } midgard_program;
 
 int
diff --git a/src/gallium/drivers/panfrost/pan_assemble.c b/src/gallium/drivers/panfrost/pan_assemble.c
index b103fe4c38..f78bb337e3 100644
--- a/src/gallium/drivers/panfrost/pan_assemble.c
+++ b/src/gallium/drivers/panfrost/pan_assemble.c
@@ -54,9 +54,20 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
 
         s->info.stage = type == JOB_TYPE_VERTEX ? MESA_SHADER_VERTEX : MESA_SHADER_FRAGMENT;
 
+        if (s->info.stage == MESA_SHADER_FRAGMENT) {
+                /* Inject the alpha test now if we need to */
+
+                if (state->alpha_state.enabled) {
+                        NIR_PASS_V(s, nir_lower_alpha_test, state->alpha_state.func, false);
+                }
+        }
+
         /* Call out to Midgard compiler given the above NIR */
 
-        midgard_program program;
+        midgard_program program = {
+                .alpha_ref = state->alpha_state.ref_value
+        };
+
         midgard_compile_shader_nir(s, &program, false);
 
         /* Prepare the compiled binary for upload */
-- 
2.18.1


From 76a626e1d7a6cd2fdb9f10f516766d708149241c Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Fri, 11 Jan 2019 05:57:11 +0000
Subject: [PATCH 21/45] Fix alpha test, maybe

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 2 +-
 src/gallium/drivers/panfrost/pan_assemble.c            | 2 +-
 src/gallium/drivers/panfrost/pan_context.c             | 2 ++
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index debb1c253c..32cb6d3a25 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -2582,7 +2582,7 @@ inline_alu_constants(compiler_context *ctx)
                                 alu->ssa_args.src1 = 4096 + alu->ssa_args.src1;
 
                                 /* Inject us -before- the last instruction which set r31 */
-                                mir_insert_instruction_before(mir_prev_op(alu), ins);
+                                //mir_insert_instruction_before(mir_prev_op(alu), ins);
                         }
                 }
         }
diff --git a/src/gallium/drivers/panfrost/pan_assemble.c b/src/gallium/drivers/panfrost/pan_assemble.c
index f78bb337e3..eac3b2e6db 100644
--- a/src/gallium/drivers/panfrost/pan_assemble.c
+++ b/src/gallium/drivers/panfrost/pan_assemble.c
@@ -45,7 +45,7 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
         struct pipe_shader_state *cso = state->base;
 
         if (cso->type == PIPE_SHADER_IR_NIR) {
-                s = cso->ir.nir;
+                s = nir_shader_clone(NULL, cso->ir.nir);
         } else {
                 assert (cso->type == PIPE_SHADER_IR_TGSI);
                 //tgsi_dump(cso->tokens, 0);
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index ed85ff0823..e0347e7299 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2046,10 +2046,12 @@ panfrost_bind_fs_state(
 
                 struct panfrost_shader_state *shader_state = &variants->variants[variant];
                 assert(panfrost_variant_matches(ctx, shader_state));
+                printf("Okay.. %d\n", variants->active_variant);
 
                 /* Now we have a variant selected, so compile and go */
 
                 if (!shader_state->compiled) {
+                        printf("Compiling more?!\n");
                         panfrost_shader_compile(ctx, &shader_state->tripipe, NULL, JOB_TYPE_TILER, shader_state);
                         shader_state->compiled = true;
                 }
-- 
2.18.1


From e1ecdbe795f888d6d7139a3e537b6c4107a15769 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 16:57:49 +0000
Subject: [PATCH 22/45] Cleanup

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 1 -
 src/gallium/drivers/panfrost/pan_context.c             | 8 ++------
 2 files changed, 2 insertions(+), 7 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 32cb6d3a25..e393f30cbf 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -1388,7 +1388,6 @@ emit_intrinsic(compiler_context *ctx, nir_intrinsic_instr *instr)
                 assert(instr->dest.is_ssa);
 
                 float ref_value = ctx->alpha_ref;
-                printf("Ref %f\n", ref_value);
 
                 float *v = ralloc_array(NULL, float, 4);
                 memcpy(v, &ref_value, sizeof(float));
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index e0347e7299..17bc9ddc29 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1733,7 +1733,7 @@ panfrost_draw_vbo(
                 const uint8_t *ibuf8 = panfrost_get_index_buffer_raw(info);
 
 
-                int min_index = (1 << 30); /* Sentinel */
+                int min_index = INT_MAX;
                 int max_index = 0;
 
                 if (info->index_size == 1) {
@@ -1749,7 +1749,7 @@ panfrost_draw_vbo(
                 }
 
                 /* Make sure we didn't go crazy */
-                assert(min_index < (1 << 30));
+                assert(min_index < INT_MAX);
                 assert(max_index > 0);
                 assert(max_index > min_index);
 
@@ -2046,12 +2046,10 @@ panfrost_bind_fs_state(
 
                 struct panfrost_shader_state *shader_state = &variants->variants[variant];
                 assert(panfrost_variant_matches(ctx, shader_state));
-                printf("Okay.. %d\n", variants->active_variant);
 
                 /* Now we have a variant selected, so compile and go */
 
                 if (!shader_state->compiled) {
-                        printf("Compiling more?!\n");
                         panfrost_shader_compile(ctx, &shader_state->tripipe, NULL, JOB_TYPE_TILER, shader_state);
                         shader_state->compiled = true;
                 }
@@ -2615,8 +2613,6 @@ panfrost_bind_depth_stencil_state(struct pipe_context *pipe,
          * emulated in the fragment shader */
 
         if (depth_stencil->alpha.enabled) {
-                printf("%f with %d\n", depth_stencil->alpha.ref_value, depth_stencil->alpha.func);
-
                 /* We need to trigger a new shader (maybe) */
                 ctx->base.bind_fs_state(&ctx->base, ctx->fs);
         }
-- 
2.18.1


From 34ac01c1819f7226367dcf0e04cf32183d354428 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 17:03:06 +0000
Subject: [PATCH 23/45] Fix double-csel the right way

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index e393f30cbf..26c6a79cc5 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -2555,9 +2555,8 @@ inline_alu_constants(compiler_context *ctx)
                 CONDITIONAL_ATTACH(src0);
 
                 if (!alu->has_constants) {
-                        if (!alu->ssa_args.inline_constant)
-                                CONDITIONAL_ATTACH(src1)
-                        } else if (!alu->ssa_args.inline_constant) {
+                        CONDITIONAL_ATTACH(src1)
+                } else {
                         /* Corner case: _two_ vec4 constants, for instance with a
                          * csel. For this case, we can only use a constant
                          * register for one, we'll have to emit a move for the
@@ -2581,7 +2580,7 @@ inline_alu_constants(compiler_context *ctx)
                                 alu->ssa_args.src1 = 4096 + alu->ssa_args.src1;
 
                                 /* Inject us -before- the last instruction which set r31 */
-                                //mir_insert_instruction_before(mir_prev_op(alu), ins);
+                                mir_insert_instruction_before(mir_prev_op(alu), ins);
                         }
                 }
         }
-- 
2.18.1


From a70cdb004a1a5d9e9c544f06e87663057d9aa53d Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 17:21:46 +0000
Subject: [PATCH 24/45] Take #3 at the double-constant problem

---
 src/gallium/drivers/panfrost/midgard/midgard_compile.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/panfrost/midgard/midgard_compile.c b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
index 26c6a79cc5..0f056bad2f 100644
--- a/src/gallium/drivers/panfrost/midgard/midgard_compile.c
+++ b/src/gallium/drivers/panfrost/midgard/midgard_compile.c
@@ -2556,7 +2556,7 @@ inline_alu_constants(compiler_context *ctx)
 
                 if (!alu->has_constants) {
                         CONDITIONAL_ATTACH(src1)
-                } else {
+                } else if (!alu->inline_constant) {
                         /* Corner case: _two_ vec4 constants, for instance with a
                          * csel. For this case, we can only use a constant
                          * register for one, we'll have to emit a move for the
@@ -2568,16 +2568,17 @@ inline_alu_constants(compiler_context *ctx)
                          */
 
                         void *entry = _mesa_hash_table_u64_search(ctx->ssa_constants, alu->ssa_args.src1 + 1);
+                        unsigned scratch = alu->ssa_args.dest;
 
                         if (entry) {
-                                midgard_instruction ins = v_fmov(SSA_FIXED_REGISTER(REGISTER_CONSTANT), blank_alu_src, 4096 + alu->ssa_args.src1);
+                                midgard_instruction ins = v_fmov(SSA_FIXED_REGISTER(REGISTER_CONSTANT), blank_alu_src, scratch);
                                 attach_constants(ctx, &ins, entry, alu->ssa_args.src1 + 1);
 
                                 /* Force a break XXX Defer r31 writes */
                                 ins.unit = UNIT_VLUT;
 
                                 /* Set the source */
-                                alu->ssa_args.src1 = 4096 + alu->ssa_args.src1;
+                                alu->ssa_args.src1 = scratch;
 
                                 /* Inject us -before- the last instruction which set r31 */
                                 mir_insert_instruction_before(mir_prev_op(alu), ins);
-- 
2.18.1


From 59aa074afbb1c901bed30ac6f5a64e1ffbad9810 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 18:00:26 +0000
Subject: [PATCH 25/45] Assert that the template->target is something we know

---
 src/gallium/drivers/panfrost/pan_context.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 17bc9ddc29..e6a3e23694 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2291,6 +2291,18 @@ panfrost_resource_create_front(struct pipe_screen *screen,
 
         if (template->depth0) sz *= template->depth0;
 
+        /* Make sure we're familiar */
+        switch (template->target) {
+                case PIPE_BUFFER:
+                case PIPE_TEXTURE_1D:
+                case PIPE_TEXTURE_2D:
+                case PIPE_TEXTURE_RECT:
+                        break;
+                default:
+                        fprintf(stderr, "Unknown texture target %d\n", template->target);
+                        assert(0);
+        }
+
         if ((template->bind & PIPE_BIND_RENDER_TARGET) || (template->bind & PIPE_BIND_DEPTH_STENCIL)) {
                 if (template->bind & PIPE_BIND_DISPLAY_TARGET ||
                     template->bind & PIPE_BIND_SCANOUT ||
-- 
2.18.1


From ac8d0d26275c93b6a6df39c22bf591f20f79b060 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 21:30:47 +0000
Subject: [PATCH 26/45] Begin depersistentification

---
 src/gallium/drivers/panfrost/pan_context.c | 129 ++++++++++++---------
 src/gallium/drivers/panfrost/pan_context.h |   5 +-
 src/gallium/drivers/panfrost/pan_nondrm.h  |   5 +
 3 files changed, 82 insertions(+), 57 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index e6a3e23694..e7fcedf290 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -48,8 +48,20 @@
 #include "pan_blend_shaders.h"
 #include "pan_wallpaper.h"
 
-/* Texture memory */
-#define HEAP_TEXTURE 0
+static struct panfrost_transfer
+panfrost_allocate_chunk(struct panfrost_context *ctx, size_t size, unsigned heap_id)
+{
+        struct pb_slab_entry *entry = pb_slab_alloc(&ctx->slabs, size, heap_id);
+        struct panfrost_memory_entry *p_entry = (struct panfrost_memory_entry *) entry;
+        struct panfrost_memory *backing = (struct panfrost_memory *) entry->slab;
+
+        struct panfrost_transfer transfer = {
+                .cpu = backing->cpu + p_entry->offset,
+                .gpu = backing->gpu + p_entry->offset
+        };
+
+        return transfer;
+}
 
 static void
 panfrost_flush(
@@ -1194,9 +1206,7 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
         }
 
         if (ctx->dirty & PAN_DIRTY_VERTEX) {
-                ctx->payload_vertex.postfix.attribute_meta = panfrost_upload(&
-                                ctx->cmdstream_persistent, &ctx->vertex->hw,
-                                sizeof(struct mali_attr_meta) * ctx->vertex->num_elements, false);
+                ctx->payload_vertex.postfix.attribute_meta = ctx->vertex->descriptor_ptr;
         }
 
         ctx->dirty |= PAN_DIRTY_VIEWPORT; /* TODO: Viewport dirty track */
@@ -1875,11 +1885,18 @@ panfrost_create_vertex_elements_state(
         unsigned num_elements,
         const struct pipe_vertex_element *elements)
 {
+        struct panfrost_context *ctx = panfrost_context(pctx);
         struct panfrost_vertex_state *so = CALLOC_STRUCT(panfrost_vertex_state);
 
         so->num_elements = num_elements;
         memcpy(so->pipe, elements, sizeof(*elements) * num_elements);
 
+        struct panfrost_transfer transfer = panfrost_allocate_chunk(ctx, sizeof(struct mali_attr_meta) * num_elements, HEAP_DESCRIPTOR);
+        so->hw = (struct mali_attr_meta *) transfer.cpu;
+        so->descriptor_ptr = transfer.gpu;
+
+        /* Allocate memory for the descriptor state */
+
         for (int i = 0; i < num_elements; ++i) {
                 so->hw[i].index = elements[i].vertex_buffer_index;
 
@@ -2965,43 +2982,6 @@ panfrost_invalidate_resource(struct pipe_context *pctx, struct pipe_resource *pr
         //fprintf(stderr, "TODO %s\n", __func__);
 }
 
-static void
-panfrost_setup_hardware(struct panfrost_context *ctx)
-{
-        struct pipe_context *gallium = (struct pipe_context *) ctx;
-        struct panfrost_screen *screen = panfrost_screen(gallium->screen);
-
-        pandev_open(screen->fd);
-
-        for (int i = 0; i < ARRAY_SIZE(ctx->transient_pools); ++i) {
-                /* Allocate the beginning of the transient pool */
-                int entry_size = (1 << 22); /* 4MB */
-
-                ctx->transient_pools[i].entry_size = entry_size;
-                ctx->transient_pools[i].entry_count = 1;
-
-                ctx->transient_pools[i].entries[0] = (struct panfrost_memory_entry *) pb_slab_alloc(&ctx->slabs, entry_size, HEAP_TRANSIENT);
-        }
-
-        panfrost_allocate_slab(ctx, &ctx->cmdstream_persistent, 8 * 64 * 8 * 2, true, 0, 0, 0);
-        panfrost_allocate_slab(ctx, &ctx->scratchpad, 64, false, 0, 0, 0);
-        panfrost_allocate_slab(ctx, &ctx->varying_mem, 16384, false, 0, 0, 0);
-        panfrost_allocate_slab(ctx, &ctx->shaders, 4096, true, BASE_MEM_PROT_GPU_EX, 0, 0);
-        panfrost_allocate_slab(ctx, &ctx->tiler_heap, 32768, false, BASE_MEM_GROW_ON_GPF, 1, 128);
-        panfrost_allocate_slab(ctx, &ctx->misc_0, 128, false, BASE_MEM_GROW_ON_GPF, 1, 128);
-}
-
-static const struct u_transfer_vtbl transfer_vtbl = {
-        .resource_create          = panfrost_resource_create,
-        .resource_destroy         = panfrost_resource_destroy,
-        .transfer_map             = panfrost_transfer_map,
-        .transfer_unmap           = panfrost_transfer_unmap,
-        .transfer_flush_region    = u_default_transfer_flush_region,
-        //.get_internal_format      = panfrost_resource_get_internal_format,
-        //.set_stencil              = panfrost_resource_set_stencil,
-        //.get_stencil              = panfrost_resource_get_stencil,
-};
-
 static struct pb_slab *
 panfrost_slab_alloc(void *priv, unsigned heap, unsigned entry_size, unsigned group_index)
 {
@@ -3048,6 +3028,55 @@ panfrost_slab_free(void *priv, struct pb_slab *slab)
         printf("stub: Tried to free slab\n");
 }
 
+static void
+panfrost_setup_hardware(struct panfrost_context *ctx)
+{
+        struct pipe_context *gallium = (struct pipe_context *) ctx;
+        struct panfrost_screen *screen = panfrost_screen(gallium->screen);
+
+        pandev_open(screen->fd);
+
+        pb_slabs_init(&ctx->slabs,
+                        MIN_SLAB_ENTRY_SIZE,
+                        MAX_SLAB_ENTRY_SIZE,
+
+                        3, /* Number of heaps */
+
+                        ctx,
+
+                        panfrost_slab_can_reclaim,
+                        panfrost_slab_alloc,
+                        panfrost_slab_free);
+
+        for (int i = 0; i < ARRAY_SIZE(ctx->transient_pools); ++i) {
+                /* Allocate the beginning of the transient pool */
+                int entry_size = (1 << 22); /* 4MB */
+
+                ctx->transient_pools[i].entry_size = entry_size;
+                ctx->transient_pools[i].entry_count = 1;
+
+                ctx->transient_pools[i].entries[0] = (struct panfrost_memory_entry *) pb_slab_alloc(&ctx->slabs, entry_size, HEAP_TRANSIENT);
+        }
+
+        panfrost_allocate_slab(ctx, &ctx->cmdstream_persistent, 8 * 64 * 8 * 2, true, 0, 0, 0);
+        panfrost_allocate_slab(ctx, &ctx->scratchpad, 64, false, 0, 0, 0);
+        panfrost_allocate_slab(ctx, &ctx->varying_mem, 16384, false, 0, 0, 0);
+        panfrost_allocate_slab(ctx, &ctx->shaders, 4096, true, BASE_MEM_PROT_GPU_EX, 0, 0);
+        panfrost_allocate_slab(ctx, &ctx->tiler_heap, 32768, false, BASE_MEM_GROW_ON_GPF, 1, 128);
+        panfrost_allocate_slab(ctx, &ctx->misc_0, 128, false, BASE_MEM_GROW_ON_GPF, 1, 128);
+}
+
+static const struct u_transfer_vtbl transfer_vtbl = {
+        .resource_create          = panfrost_resource_create,
+        .resource_destroy         = panfrost_resource_destroy,
+        .transfer_map             = panfrost_transfer_map,
+        .transfer_unmap           = panfrost_transfer_unmap,
+        .transfer_flush_region    = u_default_transfer_flush_region,
+        //.get_internal_format      = panfrost_resource_get_internal_format,
+        //.set_stencil              = panfrost_resource_set_stencil,
+        //.get_stencil              = panfrost_resource_get_stencil,
+};
+
 /* New context creation, which also does hardware initialisation since I don't
  * know the better way to structure this :smirk: */
 
@@ -3142,12 +3171,13 @@ panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
         gallium->end_query = panfrost_end_query;
         gallium->get_query_result = panfrost_get_query_result;
 
-
         gallium->blit = panfrost_blit;
 
         gallium->flush_resource = panfrost_flush_resource;
         gallium->invalidate_resource = panfrost_invalidate_resource;
 
+        panfrost_setup_hardware(ctx);
+
         /* XXX: leaks */
         gallium->stream_uploader = u_upload_create_default(gallium);
         gallium->const_uploader = gallium->stream_uploader;
@@ -3160,20 +3190,7 @@ panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
         ctx->blitter = util_blitter_create(gallium);
         assert(ctx->blitter);
 
-        pb_slabs_init(&ctx->slabs,
-                        MIN_SLAB_ENTRY_SIZE,
-                        MAX_SLAB_ENTRY_SIZE,
-
-                        2, /* Number of heaps */
-
-                        ctx,
-
-                        panfrost_slab_can_reclaim,
-                        panfrost_slab_alloc,
-                        panfrost_slab_free);
-
         /* Prepare for render! */
-        panfrost_setup_hardware(ctx);
 
         /* TODO: XXX */
         ctx->vt_framebuffer = panfrost_emit_fbd(ctx);
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 2205f2be07..7ddbe437be 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -298,8 +298,11 @@ struct panfrost_vertex_state {
         unsigned num_elements;
 
         struct pipe_vertex_element pipe[PIPE_MAX_ATTRIBS];
-        struct mali_attr_meta hw[PIPE_MAX_ATTRIBS];
         int nr_components[PIPE_MAX_ATTRIBS];
+
+        /* The actual attribute meta, prebaked and GPU mapped. TODO: Free memory */
+        struct mali_attr_meta *hw;
+        mali_ptr descriptor_ptr;
 };
 
 struct panfrost_sampler_state {
diff --git a/src/gallium/drivers/panfrost/pan_nondrm.h b/src/gallium/drivers/panfrost/pan_nondrm.h
index 9031599c91..d8fdcbcbf0 100644
--- a/src/gallium/drivers/panfrost/pan_nondrm.h
+++ b/src/gallium/drivers/panfrost/pan_nondrm.h
@@ -61,6 +61,11 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
 
 #define HEAP_TRANSIENT 1
 
+/* Multi-frame descriptor memory (replaces what used to be
+ * cmdstream_persistent), for long-living small allocations */
+
+#define HEAP_DESCRIPTOR 2
+
 /* Represents a fat pointer for GPU-mapped memory, returned from the transient
  * allocator and not used for much else */
 
-- 
2.18.1


From 64f023d7baaf113a5b61e9e713d0ac694dc73889 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 22:02:59 +0000
Subject: [PATCH 27/45] Depersistentify varyings descriptor

---
 src/gallium/drivers/panfrost/pan_allocate.c | 17 ++++++
 src/gallium/drivers/panfrost/pan_assemble.c | 68 ++++++++++++++-------
 src/gallium/drivers/panfrost/pan_context.c  | 43 ++-----------
 src/gallium/drivers/panfrost/pan_context.h  |  8 +--
 src/gallium/drivers/panfrost/pan_nondrm.h   |  3 +
 5 files changed, 73 insertions(+), 66 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_allocate.c b/src/gallium/drivers/panfrost/pan_allocate.c
index 0a4b6e3f25..65c052d6ac 100644
--- a/src/gallium/drivers/panfrost/pan_allocate.c
+++ b/src/gallium/drivers/panfrost/pan_allocate.c
@@ -34,6 +34,23 @@
 /* TODO: What does this actually have to be? */
 #define ALIGNMENT 128
 
+/* Allocate a mapped chunk directly from a heap */
+
+struct panfrost_transfer
+panfrost_allocate_chunk(struct panfrost_context *ctx, size_t size, unsigned heap_id)
+{
+        struct pb_slab_entry *entry = pb_slab_alloc(&ctx->slabs, size, heap_id);
+        struct panfrost_memory_entry *p_entry = (struct panfrost_memory_entry *) entry;
+        struct panfrost_memory *backing = (struct panfrost_memory *) entry->slab;
+
+        struct panfrost_transfer transfer = {
+                .cpu = backing->cpu + p_entry->offset,
+                .gpu = backing->gpu + p_entry->offset
+        };
+
+        return transfer;
+}
+
 /* Transient command stream pooling: command stream uploads try to simply copy
  * into whereever we left off. If there isn't space, we allocate a new entry
  * into the pool and copy there */
diff --git a/src/gallium/drivers/panfrost/pan_assemble.c b/src/gallium/drivers/panfrost/pan_assemble.c
index eac3b2e6db..84354b0b08 100644
--- a/src/gallium/drivers/panfrost/pan_assemble.c
+++ b/src/gallium/drivers/panfrost/pan_assemble.c
@@ -140,28 +140,28 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
                 /* Setup gl_Position and its weirdo analogue */
                 unsigned default_vec4_swizzle = panfrost_get_default_swizzle(4);
 
-                struct mali_attr_meta position_meta = {
-                        .index = 1,
-                        .format = MALI_VARYING_POS,
+                struct mali_attr_meta position_metas[2] = {
+                        {
+                                .index = 1,
+                                .format = MALI_VARYING_POS,
 
-                        .swizzle = default_vec4_swizzle,
-                        .unknown1 = 0x2,
-                };
-
-                struct mali_attr_meta position_meta_prime = {
-                        .index = 1,
-                        .format = MALI_RGBA16F,
+                                .swizzle = default_vec4_swizzle,
+                                .unknown1 = 0x2,
+                        },
+                        {
+                                .index = 1,
+                                .format = MALI_RGBA16F,
 
-                        /* TODO: Wat? yyyy swizzle? */
-                        .swizzle = 0x249,
-                        .unknown1 = 0x0,
+                                /* TODO: Wat? yyyy swizzle? */
+                                .swizzle = 0x249,
+                                .unknown1 = 0x0,
+                        }
                 };
 
-                varyings->vertex_only_varyings[0] = position_meta;
-                varyings->vertex_only_varyings[1] = position_meta_prime;
-
                 /* Setup actual varyings. XXX: Don't assume vec4 */
 
+                struct mali_attr_meta mali_varyings[PIPE_MAX_ATTRIBS];
+
                 for (int i = 0; i < varying_count; ++i) {
                         struct mali_attr_meta vec4_varying_meta = {
                                 .index = 0,
@@ -174,15 +174,37 @@ panfrost_shader_compile(struct panfrost_context *ctx, struct mali_shader_meta *m
                                 .src_offset = 8 * i,
                         };
 
-                        varyings->varyings[i] = vec4_varying_meta;
+                        mali_varyings[i] = vec4_varying_meta;
                 }
 
-                /* In this context, position_meta represents the implicit
-                 * gl_FragCoord varying */
-
-                varyings->fragment_only_varyings[0] = position_meta;
-                varyings->fragment_only_varying_count = 1;
-
+                /* XXX: Where did this off-by-one come from again? :P
+                 * (gl_Position probably) */
                 varyings->varying_count = varying_count - 1;
+
+                /* In this context, position_meta represents the implicit
+                 * gl_FragCoord varying. So, upload all the varyings */
+
+                unsigned varyings_size = sizeof(struct mali_attr_meta) * varyings->varying_count;
+                unsigned vertex_size = sizeof(position_metas) + varyings_size;
+                unsigned fragment_size = varyings_size + sizeof(struct mali_attr_meta);
+
+                struct panfrost_transfer transfer = panfrost_allocate_chunk(ctx, vertex_size + fragment_size, HEAP_DESCRIPTOR);
+
+                /* Copy varyings in the follow order:
+                 *  - Position 1, 2
+                 *  - Varyings 1, 2, ..., n
+                 *  - Varyings 1, 2, ..., n (duplicate)
+                 *  - Position 1
+                 */
+
+                memcpy(transfer.cpu, position_metas, sizeof(position_metas));
+                memcpy(transfer.cpu + sizeof(position_metas), mali_varyings, varyings_size);
+                memcpy(transfer.cpu + vertex_size, mali_varyings, varyings_size);
+                memcpy(transfer.cpu + vertex_size + varyings_size, &position_metas[0], sizeof(struct mali_attr_meta));
+
+                /* Point to the descriptor */
+                varyings->varyings_buffer_cpu = transfer.cpu;
+                varyings->varyings_descriptor = transfer.gpu;
+                varyings->varyings_descriptor_fragment = transfer.gpu + vertex_size;
         }
 }
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index e7fcedf290..8faa80c04f 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -48,21 +48,6 @@
 #include "pan_blend_shaders.h"
 #include "pan_wallpaper.h"
 
-static struct panfrost_transfer
-panfrost_allocate_chunk(struct panfrost_context *ctx, size_t size, unsigned heap_id)
-{
-        struct pb_slab_entry *entry = pb_slab_alloc(&ctx->slabs, size, heap_id);
-        struct panfrost_memory_entry *p_entry = (struct panfrost_memory_entry *) entry;
-        struct panfrost_memory *backing = (struct panfrost_memory *) entry->slab;
-
-        struct panfrost_transfer transfer = {
-                .cpu = backing->cpu + p_entry->offset,
-                .gpu = backing->gpu + p_entry->offset
-        };
-
-        return transfer;
-}
-
 static void
 panfrost_flush(
         struct pipe_context *pipe,
@@ -93,29 +78,6 @@ static bool USE_TRANSACTION_ELIMINATION = false;
  * can force it regardless of gallium saying we don't have it */
 static bool FORCE_MSAA = true;
 
-/* Descriptor is generated along with the shader compiler */
-
-static void
-panfrost_upload_varyings_descriptor(struct panfrost_context *ctx)
-{
-        struct panfrost_varyings *varyings = &ctx->vs->variants[ctx->vs->active_variant].varyings;
-
-        /* First, upload gl_Position varyings */
-        mali_ptr gl_Position = panfrost_upload(&ctx->cmdstream_persistent, varyings->vertex_only_varyings, sizeof(varyings->vertex_only_varyings), true);
-
-        /* Then, upload normal varyings for vertex shaders */
-        panfrost_upload_sequential(&ctx->cmdstream_persistent, varyings->varyings, sizeof(varyings->varyings[0]) * varyings->varying_count);
-
-        /* Then, upload normal varyings for fragment shaders (duplicating) */
-        mali_ptr varyings_fragment = panfrost_upload_sequential(&ctx->cmdstream_persistent, varyings->varyings, sizeof(varyings->varyings[0]) * varyings->varying_count);
-
-        /* Finally, upload gl_FragCoord varying */
-        panfrost_upload_sequential(&ctx->cmdstream_persistent, varyings->fragment_only_varyings, sizeof(varyings->fragment_only_varyings[0]) * varyings->fragment_only_varying_count);
-
-        ctx->payload_vertex.postfix.varying_meta = gl_Position;
-        ctx->payload_tiler.postfix.varying_meta = varyings_fragment;
-}
-
 /* TODO: Sample size, etc */
 
 static void
@@ -1105,7 +1067,10 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                  * fragment shader, I suppose, but it's generated with the
                  * vertex shader so */
 
-                panfrost_upload_varyings_descriptor(ctx);
+                struct panfrost_varyings *varyings = &ctx->vs->variants[ctx->vs->active_variant].varyings;
+
+                ctx->payload_vertex.postfix.varying_meta = varyings->varyings_descriptor;
+                ctx->payload_tiler.postfix.varying_meta = varyings->varyings_descriptor_fragment;
         }
 
         if (ctx->dirty & PAN_DIRTY_FS) {
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 7ddbe437be..79c8386741 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -253,10 +253,10 @@ struct panfrost_varyings {
         unsigned varying_count;
         unsigned varying_buffer_count;
 
-        struct mali_attr_meta vertex_only_varyings[2];
-        struct mali_attr_meta varyings[PIPE_MAX_ATTRIBS];
-        struct mali_attr_meta fragment_only_varyings[1];
-        int fragment_only_varying_count;
+        /* Map of the actual varyings buffer */
+        uint8_t *varyings_buffer_cpu;
+        mali_ptr varyings_descriptor;
+        mali_ptr varyings_descriptor_fragment;
 };
 
 /* Variants bundle together to form the backing CSO, bundling multiple
diff --git a/src/gallium/drivers/panfrost/pan_nondrm.h b/src/gallium/drivers/panfrost/pan_nondrm.h
index d8fdcbcbf0..5cb88f7d40 100644
--- a/src/gallium/drivers/panfrost/pan_nondrm.h
+++ b/src/gallium/drivers/panfrost/pan_nondrm.h
@@ -127,6 +127,9 @@ panfrost_reserve(struct panfrost_memory *mem, size_t sz)
         return mem->gpu + (mem->stack_bottom - sz);
 }
 
+struct panfrost_transfer
+panfrost_allocate_chunk(struct panfrost_context *ctx, size_t size, unsigned heap_id);
+
 #include <math.h>
 #define inff INFINITY
 
-- 
2.18.1


From 4086183604aa8f466d7db941b0ce1aba32b8d53f Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 22:59:34 +0000
Subject: [PATCH 28/45] FS should be transient

---
 src/gallium/drivers/panfrost/pan_allocate.c |  2 ++
 src/gallium/drivers/panfrost/pan_context.c  | 12 ++++++++++--
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_allocate.c b/src/gallium/drivers/panfrost/pan_allocate.c
index 65c052d6ac..b9434ab9e2 100644
--- a/src/gallium/drivers/panfrost/pan_allocate.c
+++ b/src/gallium/drivers/panfrost/pan_allocate.c
@@ -39,6 +39,8 @@
 struct panfrost_transfer
 panfrost_allocate_chunk(struct panfrost_context *ctx, size_t size, unsigned heap_id)
 {
+        size = ALIGN(size, ALIGNMENT);
+
         struct pb_slab_entry *entry = pb_slab_alloc(&ctx->slabs, size, heap_id);
         struct panfrost_memory_entry *p_entry = (struct panfrost_memory_entry *) entry;
         struct panfrost_memory *backing = (struct panfrost_memory *) entry->slab;
diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 8faa80c04f..e3deac902d 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1073,6 +1073,10 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 ctx->payload_tiler.postfix.varying_meta = varyings->varyings_descriptor_fragment;
         }
 
+        /* TODO: Maybe dirty track FS, maybe not. For now, it's transient. */
+        if (ctx->fs)
+                ctx->dirty |= PAN_DIRTY_FS;
+
         if (ctx->dirty & PAN_DIRTY_FS) {
                 assert(ctx->fs);
                 struct panfrost_shader_state *variant = &ctx->fs->variants[ctx->fs->active_variant];
@@ -1121,7 +1125,11 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 if (ctx->blend->has_blend_shader)
                         ctx->fragment_shader_core.blend_shader = ctx->blend->blend_shader;
 
-                ctx->payload_tiler.postfix._shader_upper = panfrost_upload(&ctx->cmdstream_persistent, &ctx->fragment_shader_core, sizeof(struct mali_shader_meta), true) >> 4;
+                size_t size = sizeof(struct mali_shader_meta) + sizeof(struct mali_blend_meta);
+                struct panfrost_transfer transfer = panfrost_allocate_transient(ctx, size);
+                memcpy(transfer.cpu, &ctx->fragment_shader_core, sizeof(struct mali_shader_meta));
+
+                ctx->payload_tiler.postfix._shader_upper = (transfer.gpu) >> 4;
 
 #ifdef T8XX
                 /* Additional blend descriptor tacked on for newer systems */
@@ -1166,7 +1174,7 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 if (ctx->blend->has_blend_shader)
                         memcpy(&blend_meta[0].blend_equation_1, &ctx->blend->blend_shader, sizeof(ctx->blend->blend_shader));
 
-                panfrost_upload_sequential(&ctx->cmdstream_persistent, blend_meta, sizeof(blend_meta));
+                memcpy(transfer.cpu + sizeof(struct mali_shader_meta), blend_meta, sizeof(blend_meta));
 #endif
         }
 
-- 
2.18.1


From 10824ef98f7fec6112f83371fd1d3dd992e9f6f4 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 23:30:21 +0000
Subject: [PATCH 29/45] VS as a mapped tripipe

---
 src/gallium/drivers/panfrost/pan_context.c | 29 ++++++++++++++++------
 src/gallium/drivers/panfrost/pan_context.h |  5 ++--
 2 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index e3deac902d..03e1bf2ecc 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1055,13 +1055,13 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 struct panfrost_shader_state *vs = &ctx->vs->variants[ctx->vs->active_variant];
 
                 /* Late shader descriptor assignments */
-                vs->tripipe.texture_count = ctx->sampler_view_count[PIPE_SHADER_VERTEX];
-                vs->tripipe.sampler_count = ctx->sampler_count[PIPE_SHADER_VERTEX];
+                vs->tripipe->texture_count = ctx->sampler_view_count[PIPE_SHADER_VERTEX];
+                vs->tripipe->sampler_count = ctx->sampler_count[PIPE_SHADER_VERTEX];
 
                 /* Who knows */
-                vs->tripipe.midgard1.unknown1 = 0x2201;
+                vs->tripipe->midgard1.unknown1 = 0x2201;
 
-                ctx->payload_vertex.postfix._shader_upper = panfrost_upload(&ctx->cmdstream_persistent, &vs->tripipe, sizeof(struct mali_shader_meta), true) >> 4;
+                ctx->payload_vertex.postfix._shader_upper = vs->tripipe_gpu >> 4;
 
                 /* Varying descriptor is tied to the vertex shader. Also the
                  * fragment shader, I suppose, but it's generated with the
@@ -1081,7 +1081,7 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 assert(ctx->fs);
                 struct panfrost_shader_state *variant = &ctx->fs->variants[ctx->fs->active_variant];
 
-#define COPY(name) ctx->fragment_shader_core.name = variant->tripipe.name
+#define COPY(name) ctx->fragment_shader_core.name = variant->tripipe->name
 
                 COPY(shader);
                 COPY(attribute_count);
@@ -2029,6 +2029,15 @@ panfrost_bind_fs_state(
 
                         variants->variants[variant].base = hwcso;
                         variants->variants[variant].alpha_state = ctx->depth_stencil->alpha;
+
+                        /* Allocate the mapped descriptor ahead-of-time. TODO: Use for FS as well as VS */
+                        struct panfrost_context *ctx = panfrost_context(pctx);
+                        struct panfrost_transfer transfer = panfrost_allocate_chunk(ctx, sizeof(struct mali_shader_meta), HEAP_DESCRIPTOR);
+
+                        variants->variants[variant].tripipe = (struct mali_shader_meta *) transfer.cpu;
+                        variants->variants[variant].tripipe_gpu = transfer.gpu;
+
+
                 }
 
                 /* Select this variant */
@@ -2040,7 +2049,7 @@ panfrost_bind_fs_state(
                 /* Now we have a variant selected, so compile and go */
 
                 if (!shader_state->compiled) {
-                        panfrost_shader_compile(ctx, &shader_state->tripipe, NULL, JOB_TYPE_TILER, shader_state);
+                        panfrost_shader_compile(ctx, shader_state->tripipe, NULL, JOB_TYPE_TILER, shader_state);
                         shader_state->compiled = true;
                 }
         }
@@ -2060,7 +2069,13 @@ panfrost_bind_vs_state(
         if (hwcso) {
                 if (!ctx->vs->variants[0].compiled) {
                         ctx->vs->variants[0].base = hwcso;
-                        panfrost_shader_compile(ctx, &ctx->vs->variants[0].tripipe, NULL, JOB_TYPE_VERTEX, &ctx->vs->variants[0]);
+
+                        /* TODO DRY from above */
+                        struct panfrost_transfer transfer = panfrost_allocate_chunk(ctx, sizeof(struct mali_shader_meta), HEAP_DESCRIPTOR);
+                        ctx->vs->variants[0].tripipe = (struct mali_shader_meta *) transfer.cpu;
+                        ctx->vs->variants[0].tripipe_gpu = transfer.gpu;
+
+                        panfrost_shader_compile(ctx, ctx->vs->variants[0].tripipe, NULL, JOB_TYPE_VERTEX, &ctx->vs->variants[0]);
                         ctx->vs->variants[0].compiled = true;
                 }
         }
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 79c8386741..14963c2e4e 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -268,9 +268,10 @@ struct panfrost_varyings {
 struct panfrost_shader_state {
         struct pipe_shader_state *base;
 
-        /* Compiled descriptor, ready for the hardware */
+        /* Compiled, mapped descriptor, ready for the hardware */
         bool compiled;
-        struct mali_shader_meta tripipe;
+        struct mali_shader_meta *tripipe;
+        mali_ptr tripipe_gpu;
 
         /* Non-descript information */
         int uniform_count;
-- 
2.18.1


From 0ced141bdefb5b68392adc13c3c90a77d7de79d8 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 23:32:14 +0000
Subject: [PATCH 30/45] Remove cmdstream_persistent

---
 src/gallium/drivers/panfrost/pan_context.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 03e1bf2ecc..5a2d4ee436 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -544,12 +544,10 @@ panfrost_viewport(struct panfrost_context *ctx,
 /* Reset per-frame context, called on context initialisation as well as after
  * flushing a frame */
 
-static int last_persistent_stack = 0;
 static void
 panfrost_invalidate_frame(struct panfrost_context *ctx)
 {
-	printf("Uploaded transient %d bytes and persistent %d bytes, \n", ctx->transient_pools[ctx->cmdstream_i].entry_index*ctx->transient_pools[0].entry_size + ctx->transient_pools[ctx->cmdstream_i].entry_offset, ctx->cmdstream_persistent.stack_bottom - last_persistent_stack);
-        last_persistent_stack = ctx->cmdstream_persistent.stack_bottom;
+	printf("Uploaded transient %d bytes \n", ctx->transient_pools[ctx->cmdstream_i].entry_index*ctx->transient_pools[0].entry_size + ctx->transient_pools[ctx->cmdstream_i].entry_offset);
 
         /* Rotate cmdstream */
         if ((++ctx->cmdstream_i) == (sizeof(ctx->transient_pools) / sizeof(ctx->transient_pools[0])))
@@ -3046,7 +3044,6 @@ panfrost_setup_hardware(struct panfrost_context *ctx)
                 ctx->transient_pools[i].entries[0] = (struct panfrost_memory_entry *) pb_slab_alloc(&ctx->slabs, entry_size, HEAP_TRANSIENT);
         }
 
-        panfrost_allocate_slab(ctx, &ctx->cmdstream_persistent, 8 * 64 * 8 * 2, true, 0, 0, 0);
         panfrost_allocate_slab(ctx, &ctx->scratchpad, 64, false, 0, 0, 0);
         panfrost_allocate_slab(ctx, &ctx->varying_mem, 16384, false, 0, 0, 0);
         panfrost_allocate_slab(ctx, &ctx->shaders, 4096, true, BASE_MEM_PROT_GPU_EX, 0, 0);
-- 
2.18.1


From c99e9ab22084bc7a353fade68a6c9823f8b824f3 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 23:38:37 +0000
Subject: [PATCH 31/45] resource_destroy by parts

---
 src/gallium/drivers/panfrost/pan_context.c | 24 ++++++++++++++++++++--
 1 file changed, 22 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 5a2d4ee436..bc0e0c4449 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2388,8 +2388,28 @@ static void
 panfrost_resource_destroy(struct pipe_screen *screen,
                           struct pipe_resource *pt)
 {
-        printf("--resource destroy--\n");
-        /* TODO */
+        struct panfrost_resource *rsrc = (struct panfrost_resource *) pt;
+
+        if (rsrc->tiled) {
+                /* CPU is all malloc'ed, so just plain ol' free needed */
+
+                for (int l = 0; l < (rsrc->base.last_level + 1); ++l) {
+                        free(rsrc->cpu[l]);
+                }
+        } else {
+                /* TODO */
+                printf("--leaking slab--\n");
+        }
+
+        if (rsrc->has_afbc) {
+                /* TODO */
+                printf("--leaking afbc--\n");
+        }
+
+        if (rsrc->has_checksum) {
+                /* TODO */
+                printf("--leaking afbc--\n");
+        }
 }
 
 static void *
-- 
2.18.1


From 374b4a010dfb34bbdd098a0101dfb9873c483d56 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Sun, 13 Jan 2019 23:46:02 +0000
Subject: [PATCH 32/45] Free linear allocations

---
 src/gallium/drivers/panfrost/pan_context.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index bc0e0c4449..abf03fc85a 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2361,6 +2361,8 @@ panfrost_resource_create_front(struct pipe_screen *screen,
                 } else {
                         /* But for linear, we can! */
 
+#if 0
+
                         struct panfrost_memory slab;
                         panfrost_allocate_slab(pscreen->any_context,
                                                &slab, (sz / 4096) + 1,
@@ -2369,6 +2371,15 @@ panfrost_resource_create_front(struct pipe_screen *screen,
                         /* Make the resource out of the slab */
                         so->cpu[0] = slab.cpu;
                         so->gpu[0] = slab.gpu;
+#endif
+
+                        struct pb_slab_entry *entry = pb_slab_alloc(&pscreen->any_context->slabs, sz, HEAP_TEXTURE);
+                        struct panfrost_memory_entry *p_entry = (struct panfrost_memory_entry *) entry;
+                        struct panfrost_memory *backing = (struct panfrost_memory *) entry->slab;
+                        so->cpu[0] = backing->cpu + p_entry->offset;
+                        so->gpu[0] = backing->gpu + p_entry->offset;
+
+                        /* TODO: Mipmap */
                 }
         }
 
@@ -2388,6 +2399,8 @@ static void
 panfrost_resource_destroy(struct pipe_screen *screen,
                           struct pipe_resource *pt)
 {
+        struct panfrost_screen *pscreen = panfrost_screen(screen);
+        struct panfrost_context *ctx = pscreen->any_context;
         struct panfrost_resource *rsrc = (struct panfrost_resource *) pt;
 
         if (rsrc->tiled) {
@@ -2396,9 +2409,11 @@ panfrost_resource_destroy(struct pipe_screen *screen,
                 for (int l = 0; l < (rsrc->base.last_level + 1); ++l) {
                         free(rsrc->cpu[l]);
                 }
+        } else if (rsrc->entry[0] != NULL) {
+                rsrc->entry[0]->freed = true;
+                pb_slab_free(&ctx->slabs, &rsrc->entry[0]->base);
         } else {
                 /* TODO */
-                printf("--leaking slab--\n");
         }
 
         if (rsrc->has_afbc) {
-- 
2.18.1


From 72f93eae37c241f774fb792133215b124cf6fda8 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 14 Jan 2019 00:20:57 +0000
Subject: [PATCH 33/45] Fix slab freeing

---
 src/gallium/drivers/panfrost/pan_context.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index abf03fc85a..6834a1819f 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2376,6 +2376,7 @@ panfrost_resource_create_front(struct pipe_screen *screen,
                         struct pb_slab_entry *entry = pb_slab_alloc(&pscreen->any_context->slabs, sz, HEAP_TEXTURE);
                         struct panfrost_memory_entry *p_entry = (struct panfrost_memory_entry *) entry;
                         struct panfrost_memory *backing = (struct panfrost_memory *) entry->slab;
+                        so->entry[0] = p_entry;
                         so->cpu[0] = backing->cpu + p_entry->offset;
                         so->gpu[0] = backing->gpu + p_entry->offset;
 
@@ -2413,7 +2414,7 @@ panfrost_resource_destroy(struct pipe_screen *screen,
                 rsrc->entry[0]->freed = true;
                 pb_slab_free(&ctx->slabs, &rsrc->entry[0]->base);
         } else {
-                /* TODO */
+                printf("--leaking main allocation--\n");
         }
 
         if (rsrc->has_afbc) {
-- 
2.18.1


From e97635f29d98486e5b01017c298854a0c375e477 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 14 Jan 2019 04:02:07 +0000
Subject: [PATCH 34/45] Permanent viewport

---
 src/gallium/drivers/panfrost/pan_context.c | 37 ++++++++++------------
 src/gallium/drivers/panfrost/pan_context.h |  2 +-
 2 files changed, 17 insertions(+), 22 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 6834a1819f..ad6ee1408d 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -537,8 +537,7 @@ panfrost_viewport(struct panfrost_context *ctx,
                 .viewport1 = { MALI_POSITIVE(viewport_x1), MALI_POSITIVE(viewport_y1) },
         };
 
-        memcpy(&ctx->viewport, &ret, sizeof(ret));
-        ctx->dirty |= PAN_DIRTY_VIEWPORT;
+        memcpy(ctx->viewport, &ret, sizeof(ret));
 }
 
 /* Reset per-frame context, called on context initialisation as well as after
@@ -597,7 +596,7 @@ panfrost_emit_vertex_payload(struct panfrost_context *ctx)
 static void
 panfrost_emit_tiler_payload(struct panfrost_context *ctx)
 {
-        struct midgard_payload_vertex_tiler payload_1 = {
+        struct midgard_payload_vertex_tiler payload = {
                 .prefix = {
                         .workgroups_z_shift = 32,
                         .workgroups_x_shift_2 = 0x2,
@@ -607,7 +606,12 @@ panfrost_emit_tiler_payload(struct panfrost_context *ctx)
                 },
         };
 
-        memcpy(&ctx->payload_tiler, &payload_1, sizeof(payload_1));
+        /* Reserve the viewport */
+        struct panfrost_transfer t = panfrost_allocate_chunk(ctx, sizeof(struct mali_viewport), HEAP_DESCRIPTOR);
+        ctx->viewport = t.cpu;
+        payload.postfix.viewport = t.gpu;
+
+        memcpy(&ctx->payload_tiler, &payload, sizeof(payload));
 }
 
 static unsigned
@@ -1180,12 +1184,6 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 ctx->payload_vertex.postfix.attribute_meta = ctx->vertex->descriptor_ptr;
         }
 
-        ctx->dirty |= PAN_DIRTY_VIEWPORT; /* TODO: Viewport dirty track */
-
-        if (ctx->dirty & PAN_DIRTY_VIEWPORT) {
-                ctx->payload_tiler.postfix.viewport = panfrost_upload_transient(ctx, &ctx->viewport, sizeof(struct mali_viewport));
-        }
-
         if (ctx->dirty & PAN_DIRTY_SAMPLERS) {
                 /* Upload samplers back to back, no padding */
 
@@ -1783,19 +1781,16 @@ panfrost_set_scissor(struct panfrost_context *ctx)
         const struct pipe_scissor_state *ss = &ctx->scissor;
 
         if (ss && ctx->rasterizer && ctx->rasterizer->base.scissor && 0) {
-                ctx->viewport.viewport0[0] = ss->minx;
-                ctx->viewport.viewport0[1] = ss->miny;
-                ctx->viewport.viewport1[0] = MALI_POSITIVE(ss->maxx);
-                ctx->viewport.viewport1[1] = MALI_POSITIVE(ss->maxy);
+                ctx->viewport->viewport0[0] = ss->minx;
+                ctx->viewport->viewport0[1] = ss->miny;
+                ctx->viewport->viewport1[0] = MALI_POSITIVE(ss->maxx);
+                ctx->viewport->viewport1[1] = MALI_POSITIVE(ss->maxy);
         } else {
-                ctx->viewport.viewport0[0] = 0;
-                ctx->viewport.viewport0[1] = 0;
-                ctx->viewport.viewport1[0] = MALI_POSITIVE(ctx->pipe_framebuffer.width);
-                ctx->viewport.viewport1[1] = MALI_POSITIVE(ctx->pipe_framebuffer.height);
-
+                ctx->viewport->viewport0[0] = 0;
+                ctx->viewport->viewport0[1] = 0;
+                ctx->viewport->viewport1[0] = MALI_POSITIVE(ctx->pipe_framebuffer.width);
+                ctx->viewport->viewport1[1] = MALI_POSITIVE(ctx->pipe_framebuffer.height);
         }
-
-        ctx->dirty |= PAN_DIRTY_VIEWPORT;
 }
 
 static void *
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 14963c2e4e..1911a537c6 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -176,7 +176,7 @@ struct panfrost_context {
 
         unsigned varying_height;
 
-        struct mali_viewport viewport;
+        struct mali_viewport *viewport;
         PANFROST_FRAMEBUFFER vt_framebuffer;
 
         /* TODO: Multiple uniform buffers (index =/= 0), finer updates? */
-- 
2.18.1


From 6e01884a1c21ad471c22fd9bd4cbdef355c34c83 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 14 Jan 2019 04:25:35 +0000
Subject: [PATCH 35/45] Directly map index buffers

---
 src/gallium/drivers/panfrost/pan_context.c | 25 +++++++++++++++++++---
 src/gallium/drivers/panfrost/pan_context.h |  2 +-
 2 files changed, 23 insertions(+), 4 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index ad6ee1408d..2c417faff0 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -608,7 +608,7 @@ panfrost_emit_tiler_payload(struct panfrost_context *ctx)
 
         /* Reserve the viewport */
         struct panfrost_transfer t = panfrost_allocate_chunk(ctx, sizeof(struct mali_viewport), HEAP_DESCRIPTOR);
-        ctx->viewport = t.cpu;
+        ctx->viewport = (struct mali_viewport *) t.cpu;
         payload.postfix.viewport = t.gpu;
 
         memcpy(&ctx->payload_tiler, &payload, sizeof(payload));
@@ -1628,6 +1628,26 @@ panfrost_get_index_buffer_raw(const struct pipe_draw_info *info)
         }
 }
 
+/* Gets a GPU address for the associated index buffer. Only gauranteed to be
+ * good for the duration of the draw (transient), could last longer */
+
+static mali_ptr
+panfrost_get_index_buffer_mapped(struct panfrost_context *ctx, const struct pipe_draw_info *info)
+{
+        struct panfrost_resource *rsrc = (struct panfrost_resource *) (info->index.resource);
+
+        off_t offset = info->start * info->index_size;
+
+        if (!info->has_user_indices) {
+                /* Only resources can be directly mapped */
+                return rsrc->gpu[0] + offset;
+        } else {
+                /* Otherwise, we need to upload to transient memory */
+                const uint8_t *ibuf8 = panfrost_get_index_buffer_raw(info);
+                return panfrost_upload_transient(ctx, ibuf8 + offset, info->count * info->index_size);
+        }
+}
+
 bool needs_dummy_draw = true;
 
 static void
@@ -1745,8 +1765,7 @@ panfrost_draw_vbo(
                 //assert(!info->min_index); /* TODO: Use value */
 
                 ctx->payload_tiler.prefix.unknown_draw |= panfrost_translate_index_size(info->index_size);
-
-                ctx->payload_tiler.prefix.indices = panfrost_upload_transient(ctx, ibuf8 + (info->start * info->index_size), info->count * info->index_size);
+                ctx->payload_tiler.prefix.indices = panfrost_get_index_buffer_mapped(ctx, info);
         } else {
                 /* Index count == vertex count, if no indexing is applied, as
                  * if it is internally indexed in the expected order */
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 1911a537c6..7fccacb022 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -65,7 +65,7 @@ struct prim_convert_context;
 #define PAN_DIRTY_VS	     (1 << 4)
 #define PAN_DIRTY_VERTEX     (1 << 5)
 #define PAN_DIRTY_VERT_BUF   (1 << 6)
-#define PAN_DIRTY_VIEWPORT   (1 << 7)
+//#define PAN_DIRTY_VIEWPORT   (1 << 7)
 #define PAN_DIRTY_SAMPLERS   (1 << 8)
 #define PAN_DIRTY_TEXTURES   (1 << 9)
 
-- 
2.18.1


From ff83c3bd5160961be4a9834bbb5491329a6bb574 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 14 Jan 2019 04:26:02 +0000
Subject: [PATCH 36/45] Smush

---
 src/gallium/drivers/panfrost/pan_context.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 2c417faff0..5b175158a7 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1313,7 +1313,6 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
 
                         /* Also attach the same buffer as a UBO for extended access */
 
-
                         struct mali_uniform_buffer_meta uniform_buffers[] = {
                                 {
                                         .size = MALI_POSITIVE((2 + uniform_count)),
@@ -1329,7 +1328,6 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 }
         }
 
-
         ctx->dirty = 0;
 }
 
@@ -1728,10 +1726,8 @@ panfrost_draw_vbo(
                 /* Calculate the min/max index used so we can figure out how
                  * many times to invoke the vertex shader */
 
-
                 const uint8_t *ibuf8 = panfrost_get_index_buffer_raw(info);
 
-
                 int min_index = INT_MAX;
                 int max_index = 0;
 
@@ -1781,7 +1777,6 @@ panfrost_draw_vbo(
         ctx->payload_vertex.prefix.invocation_count = MALI_POSITIVE(invocation_count);
         ctx->payload_tiler.prefix.invocation_count = MALI_POSITIVE(invocation_count);
 
-
         /* Fire off the draw itself */
         panfrost_queue_draw(ctx);
 }
@@ -2049,7 +2044,6 @@ panfrost_bind_fs_state(
                         variants->variants[variant].tripipe = (struct mali_shader_meta *) transfer.cpu;
                         variants->variants[variant].tripipe_gpu = transfer.gpu;
 
-
                 }
 
                 /* Select this variant */
-- 
2.18.1


From 03f15fd1f14c37448f79b60fd4f882b6fa926bcc Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 14 Jan 2019 04:26:39 +0000
Subject: [PATCH 37/45] Remove misleading commented code

---
 src/gallium/drivers/panfrost/pan_context.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 5b175158a7..77b7925c9e 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1753,7 +1753,7 @@ panfrost_draw_vbo(
                 ctx->payload_vertex.draw_start = min_index;
                 ctx->payload_tiler.draw_start = min_index;
 
-                ctx->payload_tiler.prefix.negative_start = /*-info->start*/ -min_index;
+                ctx->payload_tiler.prefix.negative_start = -min_index;
                 ctx->payload_tiler.prefix.index_count = MALI_POSITIVE(info->count);
 
                 //assert(!info->restart_index); /* TODO: Research */
-- 
2.18.1


From 30468336a45fd5ed0dce50ed8d160c93d463a209 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Mon, 14 Jan 2019 04:39:36 +0000
Subject: [PATCH 38/45] Dump what we're leaking so we remember

---
 src/gallium/drivers/panfrost/pan_context.c | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 77b7925c9e..ae637080bb 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1905,6 +1905,13 @@ panfrost_bind_vertex_elements_state(
         ctx->dirty |= PAN_DIRTY_VERTEX;
 }
 
+static void
+panfrost_delete_vertex_elements_state(struct pipe_context *pctx, void *hwcso)
+{
+        printf("Vertex elements delete leaks descriptor\n");
+        free(hwcso);
+}
+
 static void *
 panfrost_create_shader_state(
         struct pipe_context *pctx,
@@ -1926,6 +1933,7 @@ panfrost_delete_shader_state(
         struct pipe_context *pctx,
         void *so)
 {
+        printf("Deleting shader state maybe leaks tokens, per-variant compiled shaders, per-variant  descriptors\n");
         free(so);
 }
 
@@ -2628,6 +2636,7 @@ static void
 panfrost_delete_blend_state(struct pipe_context *pipe,
                             void *blend)
 {
+        printf("Deleting blend state may leak blend shader\n");
         free(blend);
 }
 
@@ -3162,7 +3171,7 @@ panfrost_create_context(struct pipe_screen *screen, void *priv, unsigned flags)
 
         gallium->create_vertex_elements_state = panfrost_create_vertex_elements_state;
         gallium->bind_vertex_elements_state = panfrost_bind_vertex_elements_state;
-        gallium->delete_vertex_elements_state = panfrost_generic_cso_delete;
+        gallium->delete_vertex_elements_state = panfrost_delete_vertex_elements_state;
 
         gallium->create_fs_state = panfrost_create_shader_state;
         gallium->delete_fs_state = panfrost_delete_shader_state;
-- 
2.18.1


From b6e47810b525e537ccf31727c242f6b83d3528d0 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 04:36:54 +0000
Subject: [PATCH 39/45] Handle predicate in query

---
 src/gallium/drivers/panfrost/pan_context.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index ae637080bb..dbd3d1c50b 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2956,7 +2956,17 @@ panfrost_get_query_result(struct pipe_context *pipe,
 {
         /* STUB */
         struct panfrost_query *query = (struct panfrost_query *) q;
-        printf("Skipped query get %d\n", query->type);
+
+        switch (query->type) {
+                case PIPE_QUERY_OCCLUSION_PREDICATE:
+                case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+                        vresult->b = false;
+                        break;
+                default:
+                        printf("Skipped query get %d\n", query->type);
+                        break;
+        }
+
         return true;
 }
 
-- 
2.18.1


From abde38706113cd525e5e753626a4f402af5d0c44 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 04:41:08 +0000
Subject: [PATCH 40/45] Check-in panwrap corresponding to occlusion boolean
 notes

---
 src/gallium/drivers/panfrost/include/panfrost-job.h    | 9 ++++++---
 src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c | 3 +++
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/src/gallium/drivers/panfrost/include/panfrost-job.h b/src/gallium/drivers/panfrost/include/panfrost-job.h
index 6cadcb1a38..4fcba675ed 100644
--- a/src/gallium/drivers/panfrost/include/panfrost-job.h
+++ b/src/gallium/drivers/panfrost/include/panfrost-job.h
@@ -73,6 +73,8 @@ enum mali_gl_mode {
         MALI_GL_TRIANGLE_FAN   = 0xC,
 };
 
+/* Applies to tiler_gl_enables */
+
 #define MALI_GL_CULL_FACE_BACK  0x80
 #define MALI_GL_CULL_FACE_FRONT 0x40
 
@@ -80,6 +82,8 @@ enum mali_gl_mode {
 #define MALI_GL_CCW (0)
 #define MALI_GL_CW  (1)
 
+#define MALI_GL_OCCLUSION_BOOLEAN 0x8
+
 /* TODO: Might this actually be a finer bitfield? */
 #define MALI_DEPTH_STENCIL_ENABLE 0x6400
 
@@ -961,14 +965,13 @@ struct mali_vertex_tiler_postfix {
 
         uintptr_t uniforms;
         u8 flags : 4;
-uintptr_t _shader_upper :
-        MALI_SHORT_PTR_BITS - 4; /* struct shader_meta */
+        uintptr_t _shader_upper : MALI_SHORT_PTR_BITS - 4; /* struct shader_meta */
         uintptr_t attributes; /* struct attribute_buffer[] */
         uintptr_t attribute_meta; /* attribute_meta[] */
         uintptr_t varyings; /* struct attr */
         uintptr_t varying_meta; /* pointer */
         uintptr_t viewport;
-        uintptr_t zero6;
+        uintptr_t occlusion_counter; /* A single bit as far as I can tell */
 
         /* Note: on Bifrost, this isn't actually the FBD. It points to
          * bifrost_scratchpad instead. However, it does point to the same thing
diff --git a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
index 21f5da583b..06aa69e3a7 100644
--- a/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
+++ b/src/gallium/drivers/panfrost/panwrap/panwrap-decoder.c
@@ -50,6 +50,7 @@
 static const struct panwrap_flag_info gl_enable_flag_info[] = {
         FLAG_INFO(CULL_FACE_FRONT),
         FLAG_INFO(CULL_FACE_BACK),
+        FLAG_INFO(OCCLUSION_BOOLEAN),
         {}
 };
 #undef FLAG_INFO
@@ -1526,6 +1527,8 @@ panwrap_replay_vertex_tiler_postfix(const struct mali_vertex_tiler_postfix *p, i
         MEMORY_COMMENT(p, varying_meta);
         DYN_MEMORY_PROP(p, job_no, viewport);
         MEMORY_COMMENT(p, viewport);
+        DYN_MEMORY_PROP(p, job_no, occlusion_counter);
+        MEMORY_COMMENT(p, occlusion_counter);
         MEMORY_COMMENT(p, framebuffer & ~1);
         panwrap_msg("%" PRIx64 "\n", p->viewport);
         panwrap_msg("%" PRIx64 "\n", p->framebuffer);
-- 
2.18.1


From 7590c371275b9a6eb568d2b97b233db0b4c0bde1 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 04:55:48 +0000
Subject: [PATCH 41/45] Allocate space for the query

---
 src/gallium/drivers/panfrost/pan_context.c | 15 ++++++++++-----
 src/gallium/drivers/panfrost/pan_context.h | 10 ++++++++++
 2 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index dbd3d1c50b..f3c6a9ce0b 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2906,11 +2906,6 @@ panfrost_blit(struct pipe_context *pipe,
         return;
 }
 
-struct panfrost_query {
-        unsigned type;
-        unsigned index;
-};
-
 static struct pipe_query *
 panfrost_create_query(struct pipe_context *pipe, 
 		      unsigned type,
@@ -2935,8 +2930,18 @@ panfrost_destroy_query(struct pipe_context *pipe, struct pipe_query *q)
 static boolean
 panfrost_begin_query(struct pipe_context *pipe, struct pipe_query *q)
 {
+        struct panfrost_context *ctx = panfrost_context(pipe);
         struct panfrost_query *query = (struct panfrost_query *) q;
         printf("Skipping query %d\n", query->type);
+
+        switch (query->type) {
+                case PIPE_QUERY_OCCLUSION_PREDICATE:
+                case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+                {
+                        /* Allocate a mapped place (just a byte, hah!) for the query */
+                        query->transfer = panfrost_allocate_chunk(ctx, 1, HEAP_DESCRIPTOR);
+                }
+        }
         /* STUB */
         return true;
 }
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index 7fccacb022..efdfe9f1c9 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -306,6 +306,16 @@ struct panfrost_vertex_state {
         mali_ptr descriptor_ptr;
 };
 
+struct panfrost_query {
+        /* Passthrough from Gallium */
+        unsigned type;
+        unsigned index;
+
+        /* Memory for the GPU to writeback the value of the query */
+        struct panfrost_transfer transfer;
+};
+
+
 struct panfrost_sampler_state {
         struct pipe_sampler_state base;
         struct mali_sampler_descriptor hw;
-- 
2.18.1


From 3d24c4ac9db05c0581569b028c9a67845bcdebc0 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 05:01:32 +0000
Subject: [PATCH 42/45] Clean up a bit of query

---
 src/gallium/drivers/panfrost/pan_context.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index f3c6a9ce0b..8bd072fe98 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2911,9 +2911,7 @@ panfrost_create_query(struct pipe_context *pipe,
 		      unsigned type,
 		      unsigned index)
 {
-        /* STUB */
         struct panfrost_query *q = CALLOC_STRUCT(panfrost_query);
-        printf("Creating query %d, %d\n", type, index);
 
         q->type = type;
         q->index = index;
@@ -2932,7 +2930,6 @@ panfrost_begin_query(struct pipe_context *pipe, struct pipe_query *q)
 {
         struct panfrost_context *ctx = panfrost_context(pipe);
         struct panfrost_query *query = (struct panfrost_query *) q;
-        printf("Skipping query %d\n", query->type);
 
         switch (query->type) {
                 case PIPE_QUERY_OCCLUSION_PREDICATE:
@@ -2940,9 +2937,14 @@ panfrost_begin_query(struct pipe_context *pipe, struct pipe_query *q)
                 {
                         /* Allocate a mapped place (just a byte, hah!) for the query */
                         query->transfer = panfrost_allocate_chunk(ctx, 1, HEAP_DESCRIPTOR);
+                        break;
                 }
+
+                default:
+                        fprintf(stderr, "Skipping query %d\n", query->type);
+                        break;
         }
-        /* STUB */
+
         return true;
 }
 
@@ -2968,7 +2970,7 @@ panfrost_get_query_result(struct pipe_context *pipe,
                         vresult->b = false;
                         break;
                 default:
-                        printf("Skipped query get %d\n", query->type);
+                        fprintf(stderr, "Skipped query get %d\n", query->type);
                         break;
         }
 
-- 
2.18.1


From 7871ffc7644312f4cd03ab3e642740a40d2ae08d Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 05:09:23 +0000
Subject: [PATCH 43/45] Read back query results

---
 src/gallium/drivers/panfrost/pan_context.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 8bd072fe98..428b534657 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2936,7 +2936,7 @@ panfrost_begin_query(struct pipe_context *pipe, struct pipe_query *q)
                 case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
                 {
                         /* Allocate a mapped place (just a byte, hah!) for the query */
-                        query->transfer = panfrost_allocate_chunk(ctx, 1, HEAP_DESCRIPTOR);
+                        query->transfer = panfrost_allocate_chunk(ctx, sizeof(unsigned), HEAP_DESCRIPTOR);
                         break;
                 }
 
@@ -2966,9 +2966,15 @@ panfrost_get_query_result(struct pipe_context *pipe,
 
         switch (query->type) {
                 case PIPE_QUERY_OCCLUSION_PREDICATE:
-                case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE:
+                case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE: {
+                        /* Read back the query results */
+                        unsigned *result = (unsigned *) query->transfer.cpu;
+                        unsigned passed = *result;
+                        printf("Read %d\n", passed);
+
                         vresult->b = false;
                         break;
+                }
                 default:
                         fprintf(stderr, "Skipped query get %d\n", query->type);
                         break;
-- 
2.18.1


From afd7767734e366ff9e897a0daa9dcb23f91dff83 Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 05:47:42 +0000
Subject: [PATCH 44/45] Pipe occlusion query through

---
 src/gallium/drivers/panfrost/pan_context.c | 16 ++++++++++++++--
 src/gallium/drivers/panfrost/pan_context.h | 21 +++++++++++----------
 2 files changed, 25 insertions(+), 12 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 428b534657..20270a2bfb 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -1048,7 +1048,11 @@ panfrost_emit_for_draw(struct panfrost_context *ctx, bool with_vertex_data)
                 ctx->payload_tiler.gl_enables = ctx->rasterizer->tiler_gl_enables;
 
                 panfrost_set_framebuffer_msaa(ctx, FORCE_MSAA || ctx->rasterizer->base.multisample);
+        }
 
+        if (ctx->occlusion_query) {
+                ctx->payload_tiler.gl_enables |= MALI_GL_OCCLUSION_BOOLEAN;
+                ctx->payload_tiler.postfix.occlusion_counter = ctx->occlusion_query->transfer.gpu;
         }
 
         if (ctx->dirty & PAN_DIRTY_VS) {
@@ -2937,6 +2941,9 @@ panfrost_begin_query(struct pipe_context *pipe, struct pipe_query *q)
                 {
                         /* Allocate a mapped place (just a byte, hah!) for the query */
                         query->transfer = panfrost_allocate_chunk(ctx, sizeof(unsigned), HEAP_DESCRIPTOR);
+
+                        ctx->occlusion_query = query;
+
                         break;
                 }
 
@@ -2951,7 +2958,8 @@ panfrost_begin_query(struct pipe_context *pipe, struct pipe_query *q)
 static bool
 panfrost_end_query(struct pipe_context *pipe, struct pipe_query *q)
 {
-        /* STUB */
+        struct panfrost_context *ctx = panfrost_context(pipe);
+        ctx->occlusion_query = NULL;
         return true;
 }
 
@@ -2961,9 +2969,13 @@ panfrost_get_query_result(struct pipe_context *pipe,
                           boolean wait,
                           union pipe_query_result *vresult)
 {
-        /* STUB */
         struct panfrost_query *query = (struct panfrost_query *) q;
 
+        /* We need to flush out the jobs to actually run the counter, TODO
+         * check wait, TODO wallpaper after if needed */
+
+        panfrost_flush(pipe, NULL, PIPE_FLUSH_END_OF_FRAME);
+
         switch (query->type) {
                 case PIPE_QUERY_OCCLUSION_PREDICATE:
                 case PIPE_QUERY_OCCLUSION_PREDICATE_CONSERVATIVE: {
diff --git a/src/gallium/drivers/panfrost/pan_context.h b/src/gallium/drivers/panfrost/pan_context.h
index efdfe9f1c9..322c46b072 100644
--- a/src/gallium/drivers/panfrost/pan_context.h
+++ b/src/gallium/drivers/panfrost/pan_context.h
@@ -75,6 +75,15 @@ struct panfrost_constant_buffer {
         void *buffer;
 };
 
+struct panfrost_query {
+        /* Passthrough from Gallium */
+        unsigned type;
+        unsigned index;
+
+        /* Memory for the GPU to writeback the value of the query */
+        struct panfrost_transfer transfer;
+};
+
 #define PANFROST_MAX_TRANSIENT_ENTRIES 64
 
 struct panfrost_transient_pool {
@@ -122,6 +131,8 @@ struct panfrost_context {
                 unsigned stencil;
         } last_clear;
 
+        struct panfrost_query *occlusion_query;
+
         /* Each render job has multiple framebuffer descriptors associated with
          * it, used for various purposes with more or less the same format. The
          * most obvious is the fragment framebuffer descriptor, which carries
@@ -306,16 +317,6 @@ struct panfrost_vertex_state {
         mali_ptr descriptor_ptr;
 };
 
-struct panfrost_query {
-        /* Passthrough from Gallium */
-        unsigned type;
-        unsigned index;
-
-        /* Memory for the GPU to writeback the value of the query */
-        struct panfrost_transfer transfer;
-};
-
-
 struct panfrost_sampler_state {
         struct pipe_sampler_state base;
         struct mali_sampler_descriptor hw;
-- 
2.18.1


From d8a5bde39a755b26ecea7f892d8bb2f8dffb80ec Mon Sep 17 00:00:00 2001
From: Alyssa Rosenzweig <alyssa@rosenzweig.io>
Date: Thu, 17 Jan 2019 05:51:33 +0000
Subject: [PATCH 45/45] Passthrough the read query

---
 src/gallium/drivers/panfrost/pan_context.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/gallium/drivers/panfrost/pan_context.c b/src/gallium/drivers/panfrost/pan_context.c
index 20270a2bfb..ba14c5544d 100644
--- a/src/gallium/drivers/panfrost/pan_context.c
+++ b/src/gallium/drivers/panfrost/pan_context.c
@@ -2982,9 +2982,8 @@ panfrost_get_query_result(struct pipe_context *pipe,
                         /* Read back the query results */
                         unsigned *result = (unsigned *) query->transfer.cpu;
                         unsigned passed = *result;
-                        printf("Read %d\n", passed);
 
-                        vresult->b = false;
+                        vresult->b = !!passed;
                         break;
                 }
                 default:
-- 
2.18.1

