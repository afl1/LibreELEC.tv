From: afl1
Date: 2017/10/5
Subject: [PATCH] VideoPlayer: AMLCodec control fixies

--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp	2017-08-09 14:14:00.726055417 +0200
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.cpp	2017-08-09 14:14:07.638597417 +0200
@@ -254,7 +254,7 @@
 #define CODEC_TAG_jpeg  (0x6765706a)
 #define CODEC_TAG_mjpa  (0x61706a6d)
 
-#define RW_WAIT_TIME    (20 * 1000) // 20ms
+#define RW_WAIT_TIME    (5 * 1000) // 20ms
 
 #define P_PRE           (0x02000000)
 #define F_PRE           (0x03000000)
@@ -671,7 +671,7 @@
     while (size > 0 && pkt->isvalid) {
         write_bytes = para->m_dll->codec_write(pkt->codec, buf, size);
         if (write_bytes < 0 || write_bytes > size) {
-            CLog::Log(LOGDEBUG, "write codec data failed, write_bytes(%d), errno(%d), size(%d)", write_bytes, errno, size);
+//            CLog::Log(LOGDEBUG, "write codec data failed, write_bytes(%d), errno(%d), size(%d)", write_bytes, errno, size);
             if (-errno != AVERROR(EAGAIN)) {
                 CLog::Log(LOGDEBUG, "write codec data failed!");
                 return PLAYER_WR_FAILED;
@@ -682,7 +682,7 @@
                 pkt->data += len;
                 pkt->data_size -= len;
                 usleep(RW_WAIT_TIME);
-                CLog::Log(LOGDEBUG, "usleep(RW_WAIT_TIME), len(%d)", len);
+                CLog::Log(LOGDEBUG, "Codec buffer full, try after %d ms, len(%d)", RW_WAIT_TIME / 1000, len);
                 return PLAYER_SUCCESS;
             }
         } else {
@@ -1442,6 +1442,8 @@
   m_state = 0;
   m_frameSizes.clear();
   m_frameSizeSum = 0;
+  m_frameCount = 0;
+  m_hints.timeToDisplay = hints.timeToDisplay;
   m_noPictureLoop = 0;
 
   if (!OpenAmlVideo(hints))
@@ -1829,6 +1830,10 @@
     am_private->am_pkt.data = pData;
     am_private->am_pkt.data_size = iSize;
 
+    struct buf_status bs;
+    m_dll->codec_get_vbuf_state(&am_private->vcodec, &bs);
+    CLog::Log(LOGDEBUG, "CAMLCodec::Decode: Adddata dl:%d rp:%u sum:%u sz:%u wait:%d", bs.data_len, bs.read_pointer, m_frameSizeSum, iSize, 1200 + iSize/800);  
+
     am_private->am_pkt.newflag    = 1;
     am_private->am_pkt.isvalid    = 1;
     am_private->am_pkt.avduration = 0;
@@ -1881,6 +1886,8 @@
     if (loop == 100)
       // Decoder got stuck; Reset
       Reset();
+    else
+      usleep(1200 + iSize/800);
   }
 
   float timesize(GetTimeSize());
@@ -1901,7 +1906,9 @@
 
   float timesize(GetTimeSize());
 
-  if (timesize > 0.5 || m_drain)
+  std::chrono::duration<double> diff = *(m_hints.timeToDisplay) - std::chrono::system_clock::now();
+      CLog::Log(LOGDEBUG, "CAMLCodec::GetPicture: VC_BUFFER LEV:%0.2f ttd:%0.0fms", timesize, diff.count()*1000.0);
+  if (timesize > 0.3 || m_drain || (diff.count() < 0.030))
     if (DequeueBuffer() == 0)
     {
       rtn |= VC_PICTURE;
@@ -1912,15 +1917,25 @@
     }
 
   if (++m_noPictureLoop == 100 || timesize == 0.0) // EOS or stalled
-    rtn |= VC_BUFFER;
+    {
+      CLog::Log(LOGDEBUG, "CAMLCodec::GetPicture: VC_BUFFER LEVEL:%0.2f ttd:%0.0fms", timesize, diff.count()*1000.0);
+      rtn |= VC_BUFFER;
+    }
 
   if (!m_drain)
-    if (timesize < 1.0)
+    if (timesize < 0.6) 
+    {
+      CLog::Log(LOGDEBUG, "CAMLCodec::GetPicture: VC_BUFFER level:%0.2f ttd:%0.0fms", timesize, diff.count()*1000.0);
       rtn |= VC_BUFFER;
+    }
 
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
   {
-    CLog::Log(LOGDEBUG, "CAMLCodec::Decode: ret: %d, sz: %u, dts_in: %0.4lf[%llX], pts_in: %0.4lf[%llX], adj:%llu, ptsOut:%0.4f, amlpts:%d, idx:%u, timesize:%0.4f, drain: %d",
+    struct buf_status bs;
+    m_dll->codec_get_vbuf_state(&am_private->vcodec, &bs);
+    if (iSize > 0) 
+     CLog::Log(LOGDEBUG, "CAMLCodec::Decode: dl:%d rp:%u sum:%u ret: %d, sz: %u, dts_in: %0.4lf[%llX], pts_in: %0.4lf[%llX], adj:%llu, ptsOut:%0.4f, amlpts:%d, idx:%u, timesize:%0.4f, drain: %d", 
+      bs.data_len, bs.read_pointer, m_frameSizeSum, 
       rtn,
       static_cast<unsigned int>(iSize),
       dts / DVD_TIME_BASE, am_private->am_pkt.avdts,
@@ -1968,7 +1974,7 @@
     vbuf.flags |= V4L2_BUF_FLAG_DONE;
 
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "CAMLCodec::ReleaseFrame idx:%u", index);
+    CLog::Log(LOGDEBUG, "CAMLCodec::ReleaseFrame idx:%u drop:%d", index, drop);
 
   if ((ret = m_amlVideoFile->IOControl(VIDIOC_QBUF, &vbuf)) < 0)
     CLog::Log(LOGERROR, "CAMLCodec::ReleaseFrame - VIDIOC_QBUF failed: %s", strerror(errno));
@@ -2000,8 +2000,11 @@
 
     std::chrono::milliseconds elapsed(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - now).count());
 
-    if (elapsed < std::chrono::milliseconds(10))
-      std::this_thread::sleep_for(std::chrono::milliseconds(10) - elapsed);
+    if (elapsed < std::chrono::milliseconds(5))
+    { 
+      CLog::Log(LOGDEBUG, "CAMLCodec::DequeueBuffer: Try again after:%ums", std::chrono::milliseconds(5) - elapsed);
+      std::this_thread::sleep_for(std::chrono::milliseconds(5) - elapsed);
+    }
 
     return -errno;
   }
@@ -2020,6 +2020,8 @@
     m_cur_pts = vbuf.timestamp.tv_usec;
   }
   m_bufferIndex = vbuf.index;
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "CAMLCodec::DequeueBuffer: idx:%u", m_bufferIndex);
   return 0;
 }
 
@@ -2030,11 +2034,14 @@
   struct buf_status bs;
   m_dll->codec_get_vbuf_state(&am_private->vcodec, &bs);
 
-  //CLog::Log(LOGDEBUG, "CAMLCodec::Decode: buf status: s:%d dl:%d fl:%d rp:%u wp:%u",bs.size, bs.data_len, bs.free_len, bs.read_pointer, bs.write_pointer);  
+  CLog::Log(LOGDEBUG, "CAMLCodec::GetTimeSize: len:%d dl:%d rp:%u fs:%u front:%u fr_count:%d ttd:%dms", 
+    m_frameSizes.size(), bs.data_len, bs.read_pointer, m_frameSizeSum, m_frameSizes.front(), m_frameCount, std::chrono::duration_cast<std::chrono::milliseconds>(*(m_hints.timeToDisplay) - std::chrono::system_clock::now()).count() ); 
   while (m_frameSizeSum >  (unsigned int)bs.data_len)
   {
     m_frameSizeSum -= m_frameSizes.front();
     m_frameSizes.pop_front();
+    m_frameCount++; 
+    CLog::Log(LOGDEBUG, "CAMLCodec::GetTimeSize: len:%d dl:%d rp:%u fs:%u front:%u fr_count:%d", m_frameSizes.size(), bs.data_len, bs.read_pointer, m_frameSizeSum, m_frameSizes.front(), m_frameCount);
   }
   if (bs.free_len < (bs.data_len >> 1))
     return 7.0;
@@ -2122,6 +2122,8 @@
   pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
   pDvdVideoPicture->pts = (double)GetCurPts() / PTS_FREQ * DVD_TIME_BASE;
 
+  CLog::Log(LOGDEBUG, "CAMLCodec::GetPicture: index: %u, pts: %0.4lf fsz:%u", m_bufferIndex, pDvdVideoPicture->pts/DVD_TIME_BASE, m_cur_pts * PTS_FREQ, m_frameSizeSum);
+  m_frameCount--;
   return true;
 }
 
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h	2017-08-13 23:19:45.000000000 +0200
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/AMLCodec.h	2017-08-15 15:08:33.979615990 +0200
@@ -111,7 +111,7 @@
 
   std::deque<uint32_t> m_frameSizes;
   std::uint32_t m_frameSizeSum;
-
+  int		m_frameCount = 0;
   static long  m_pollSync;
   static int m_pollDevice;
 };
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp	2017-08-09 15:15:54.203655824 +0200
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp	2017-08-09 21:44:18.266213954 +0200
@@ -1734,6 +1740,7 @@
   if (CheckSceneSkip(m_CurrentVideo))
     drop = true;
 
+  CLog::Log(LOGDEBUG, "CVideoPlayer::ProcesVideoData size:%d dts:%0.4f pts:%0.4f dur:%0.3fms, clock:%0.4f", pPacket->iSize, pPacket->dts/1000000, pPacket->pts/1000000, pPacket->duration/1000.0, m_clock.GetClock()/1000);
   m_VideoPlayerVideo->SendMessage(new CDVDMsgDemuxerPacket(pPacket, drop));
   m_CurrentVideo.packets++;
 }
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp	2017-08-10 00:33:35.164554941 +0200
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp	2017-08-10 11:51:08.091697999 +0200
@@ -120,6 +120,9 @@
 bool CVideoPlayerVideo::OpenStream( CDVDStreamInfo &hint )
 {
   m_processInfo.ResetVideoCodecInfo();
+  m_hints = hint;
+  m_timeToDisplay = std::chrono::system_clock::now() + std::chrono::milliseconds(10000);
+  m_hints.timeToDisplay = &m_timeToDisplay;

   CRenderInfo info;
   info = m_renderManager.GetRenderInfo();
@@ -128,8 +131,8 @@
   if(hint.flags & AV_DISPOSITION_ATTACHED_PIC)
     return false;
 
-  CLog::Log(LOGNOTICE, "Creating video codec with codec id: %i", hint.codec);
-  CDVDVideoCodec* codec = CDVDFactoryCodec::CreateVideoCodec(hint, m_processInfo, info);
+  CLog::Log(LOGNOTICE, "Creating video codec with codec id: %i", m_hints.codec);
+  CDVDVideoCodec* codec = CDVDFactoryCodec::CreateVideoCodec(m_hints, m_processInfo, info);
   if(!codec)
   {
     CLog::Log(LOGERROR, "Unsupported video codec");
@@ -137,7 +140,7 @@
   }
 
   if(m_messageQueue.IsInited())
-    m_messageQueue.Put(new CDVDMsgVideoCodecChange(hint, codec), 0);
+    m_messageQueue.Put(new CDVDMsgVideoCodecChange(m_hints, codec), 0);
   else
   {
     OpenStream(hint, codec);
@@ -322,6 +325,7 @@
       m_syncState = IDVDStreamPlayer::SYNC_INSYNC;
       m_droppingStats.Reset();
       m_rewindStalled = false;
+      m_timeToDisplay = std::chrono::system_clock::now() + std::chrono::milliseconds(700);
 
       CLog::Log(LOGDEBUG, "CVideoPlayerVideo - CDVDMsg::GENERAL_RESYNC(%f)", pts);
     }
@@ -863,7 +867,9 @@
   // don't wait when going ff
   if (m_speed > DVD_PLAYSPEED_NORMAL)
     maxWaitTime = std::max(timeToDisplay, 0);
+  m_timeToDisplay = std::chrono::system_clock::now() + std::chrono::milliseconds(timeToDisplay);
   int buffer = m_renderManager.WaitForBuffer(m_bAbortOutput, maxWaitTime);
+  CLog::Log(LOGDEBUG,"CVideoPlayerVideo::%s - timeToDisplay: %dms pts: %0.4lf Level:%d", __FUNCTION__, timeToDisplay, pPicture->pts/1000000, buffer);
   if (buffer < 0)
   {
     m_droppingStats.AddOutputDropGain(pts, 1);
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp	2017-08-08 11:26:45.000000000 +0200
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp	2017-08-10 22:46:47.710636550 +0200
@@ -95,6 +95,7 @@
 void CRendererAML::AddVideoPictureHW(DVDVideoPicture &picture, int index)
 {
   BUFFER &buf = m_buffers[index];
+  CLog::Log(LOGDEBUG, "CRendererAML::AddVideoPicture: idx:%d, pts:%0.4lf", index, picture.pts / 1000000);
   if (picture.amlcodec)
     buf.hwDec = picture.amlcodec->Retain();
 }
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.h	2017-08-19 19:05:15.000000000 +0200
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.h	2017-09-07 15:41:21.609247158 +0200
@@ -31,6 +31,7 @@
 #include "cores/VideoPlayer/VideoRenderers/RenderManager.h"
 #include "utils/BitstreamStats.h"
 #include <atomic>
+#include <chrono>
 
 class CDemuxStreamVideo;
 
@@ -148,5 +149,6 @@
   CDroppingStats m_droppingStats;
   CRenderManager& m_renderManager;
   DVDVideoPicture m_picture;
+  std::chrono::time_point<std::chrono::system_clock>   m_timeToDisplay;
 };
 
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.h	2017-08-19 19:05:15.000000000 +0200
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.h	2017-09-07 15:04:58.009993157 +0200
@@ -30,6 +30,7 @@
 extern "C" {
 #include "libavcodec/avcodec.h"
 }
+#include <chrono>
 
 class CDemuxStream;
 
@@ -73,6 +74,7 @@
   int orientation; // orientation of the video in degress counter clockwise
   int bitsperpixel;
   std::string stereo_mode; // stereoscopic 3d mode
+  std::chrono::time_point<std::chrono::system_clock> *timeToDisplay;
 
   // AUDIO
   int channels;
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp	2017-09-07 23:44:34.453939999 +0200
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecAmlogic.cpp	2017-09-08 00:44:23.871752000 +0200
@@ -80,6 +80,7 @@
   }
 
   m_hints = hints;
+  m_hints.timeToDisplay = hints.timeToDisplay;
 
   switch(m_hints.codec)
   {
--
